{
    "docs": [
        {
            "location": "/",
            "text": "Sduino\n\n\nPorting the most important features of the Arduino API to the STM8S.\n\n\nWithin a few minutes you are ready to compile and upload your first\nSTM8S-based project while still retaining the flexibility to use ST's SPL\nfunctions.\n\n\nAll you need to get started is a simple STM8S103F breakout board for 70\ncents and a ST-Link V2 compatible flash programmer for $2.50. Three boards\nand one flash programmer together are available for well under five dollars\nincluding shipping on\n\naliexpress\n.\n\n\nAmazing!\n\n\nUsage\n\n\nThe recommanded way of installation is now the Arduino Board Manager:\n\n\n\n\nOpen the Settings tab of the Preferences dialog\n\n\nEnter\n  \nhttps://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json\n\n  as an Additional Boards Manager URL\n\n\nSelect \nsduino\n in the Boards Manager list (Tools->Board:...->Boards Manager)\n\n\nClick on Install\n\n\n\n\nWait for the download to finsh and you are ready to blink:\n\n\n\n\nOpen the Boards list at Tools->Board:...\n\n\nYou should find a new entry \"STM8S Boards\".\n\n\nChoose \nSTM8S103F3 Breakout Board\n from the list\n\n\nOpen the standard Blink example from File->Examples->01. Basics->Blink\n\n\nCompile it by hitting 'Verify'\n\n\n\n\nWasn't too hard, was it?\n\n\nIncluded libraries\n\n\nSome Arduino libraries are already ported to C-syntax. The resulting API is\nstill very close to the C++ version and porting an existing application is\nnot hard. Check out the \nAPI migration guidelines\n for\ndetails.\n\n\nCommunication\n\n\n\n\nSPI\n: Real hardware-SPI up to 10MHz.\n\n\nI2C\n: Port of the I2C master library by Wayne Truchsess\n\n\nHardwareSerial: The standard serial interface.\n\n\n\n\nDisplays\n\n\n\n\nLiquidCrystal\n: HD44780 based text LCDs\n\n\nPCD8544\n: Monochrome graphical LCD based on the PCD8544\n  controller like the Nokia 5110 display. SPI mode only.\n\n\nMini_SSD1306\n: SSD1306-based monochrome OLED displays\n  with 128x64 pixels. I2C support only.\n\n\n\n\nMotor control\n\n\n\n\nStepper\n: Stepper motors with 2, 4 or 5 phases.\n\n\nServo\n: Up to 12 servos using only 1 timer.\n\n\n\n\nSupported hardware\n\n\n\n\n\n\nThe \none-dollar-boards\n: A simple STM8S103 breakout\n  board build around a CPU STM8S103F3P6. It costs less than a dollar. The\n  CPU features a 16MHz internal oscillator, 8kB flash, 1kB RAM, 640 byte\n  EEPROM. It includes an UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to\n  14 I/O pins - quite similar to an Atmel ATmega8.\n\n\n\n\n\n\nThe \nESP14 Wifi-boards\n are very similar. They are\n  basically a variant of these boards with an added ESP-01 Wifi-module. Almost\n  all programs should run on those chinese Wifi-enabled gems as well.\n\n\n\n\n\n\nThe \nSTM8S105Discovery-boards\n are very similar\n  to an Arduino Uno with an ATmega328 CPU. The support for the used STM8S105\n  CPU is still quite fresh but it should work now.\n\n\n\n\n\n\nLimitations\n\n\nSDCC doesn't support C++. Some preprocessor magic is applied to close the\ngap between C and C++ syntax as much as possible, but this is not a 100%\ncompatible drop-in replacement for full Arduino environments like for AVR or\nSTM32. See \nLimitations\n and the\n\nmigration guidelines\n for details.\n\n\nSupported Systems\n\n\n\n\nLinux 64 bit: Tested on Ubuntu 16.04\n\n\nLinux 32 bit: Tested on Ubuntu 16.04\n\n\nWindows: Tested on Windows 7. Sduino might work on XP (not tested), but\n  the ST-Link/V2 driver is not available anymore for XP.\n\n\nMacOS: Not tested, but should be very close to working. Will need a manual\n  install, but IDE integration should be easy now. Any volunteers?\n\n\nRaspian/Raspberry Pi: Untested. Will require a manual install.",
            "title": "Introduction"
        },
        {
            "location": "/#sduino",
            "text": "Porting the most important features of the Arduino API to the STM8S.  Within a few minutes you are ready to compile and upload your first\nSTM8S-based project while still retaining the flexibility to use ST's SPL\nfunctions.  All you need to get started is a simple STM8S103F breakout board for 70\ncents and a ST-Link V2 compatible flash programmer for $2.50. Three boards\nand one flash programmer together are available for well under five dollars\nincluding shipping on aliexpress .  Amazing!  Usage  The recommanded way of installation is now the Arduino Board Manager:   Open the Settings tab of the Preferences dialog  Enter\n   https://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json \n  as an Additional Boards Manager URL  Select  sduino  in the Boards Manager list (Tools->Board:...->Boards Manager)  Click on Install   Wait for the download to finsh and you are ready to blink:   Open the Boards list at Tools->Board:...  You should find a new entry \"STM8S Boards\".  Choose  STM8S103F3 Breakout Board  from the list  Open the standard Blink example from File->Examples->01. Basics->Blink  Compile it by hitting 'Verify'   Wasn't too hard, was it?  Included libraries  Some Arduino libraries are already ported to C-syntax. The resulting API is\nstill very close to the C++ version and porting an existing application is\nnot hard. Check out the  API migration guidelines  for\ndetails.  Communication   SPI : Real hardware-SPI up to 10MHz.  I2C : Port of the I2C master library by Wayne Truchsess  HardwareSerial: The standard serial interface.   Displays   LiquidCrystal : HD44780 based text LCDs  PCD8544 : Monochrome graphical LCD based on the PCD8544\n  controller like the Nokia 5110 display. SPI mode only.  Mini_SSD1306 : SSD1306-based monochrome OLED displays\n  with 128x64 pixels. I2C support only.   Motor control   Stepper : Stepper motors with 2, 4 or 5 phases.  Servo : Up to 12 servos using only 1 timer.   Supported hardware    The  one-dollar-boards : A simple STM8S103 breakout\n  board build around a CPU STM8S103F3P6. It costs less than a dollar. The\n  CPU features a 16MHz internal oscillator, 8kB flash, 1kB RAM, 640 byte\n  EEPROM. It includes an UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to\n  14 I/O pins - quite similar to an Atmel ATmega8.    The  ESP14 Wifi-boards  are very similar. They are\n  basically a variant of these boards with an added ESP-01 Wifi-module. Almost\n  all programs should run on those chinese Wifi-enabled gems as well.    The  STM8S105Discovery-boards  are very similar\n  to an Arduino Uno with an ATmega328 CPU. The support for the used STM8S105\n  CPU is still quite fresh but it should work now.    Limitations  SDCC doesn't support C++. Some preprocessor magic is applied to close the\ngap between C and C++ syntax as much as possible, but this is not a 100%\ncompatible drop-in replacement for full Arduino environments like for AVR or\nSTM32. See  Limitations  and the migration guidelines  for details.  Supported Systems   Linux 64 bit: Tested on Ubuntu 16.04  Linux 32 bit: Tested on Ubuntu 16.04  Windows: Tested on Windows 7. Sduino might work on XP (not tested), but\n  the ST-Link/V2 driver is not available anymore for XP.  MacOS: Not tested, but should be very close to working. Will need a manual\n  install, but IDE integration should be easy now. Any volunteers?  Raspian/Raspberry Pi: Untested. Will require a manual install.",
            "title": "Sduino"
        },
        {
            "location": "/usage/board-manager-install/",
            "text": "Installation\n\n\nUsing the Arduino Board Manager\n\n\nThis is the recommanded way of installation now.\n\n\n\n\nOpen the Settings tab of the Preferences dialog\n\n\nEnter\n  \nhttps://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json\n\n  as an Additional Boards Manager URL\n\n\nSelect \nsduino\n in the Boards Manager list (Tools->Board:...->Boards Manager)\n\n\nClick on Install\n\n\n\n\nWait for the download to finsh and you are ready to blink:\n\n\n\n\nOpen the Boards list at Tools->Board:...\n\n\nYou should find a new entry \"STM8S Boards\".\n\n\nChoose \nSTM8S103F3 Breakout Board\n from the list\n\n\nOpen the standard Blink example from File->Examples->01. Basics->Blink\n\n\nCompile it by hitting 'Verify'\n\n\n\n\nWasn't too hard, was it?\n\n\nManual install\n\n\nOnly if you prefer a Makefile based build over using the Arduino IDE or if\nyou would like to help with the development of Sduino you will have to do a\n\nmanual installation\n instead.",
            "title": "Automatic Installation"
        },
        {
            "location": "/usage/board-manager-install/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/usage/board-manager-install/#using-the-arduino-board-manager",
            "text": "This is the recommanded way of installation now.   Open the Settings tab of the Preferences dialog  Enter\n   https://github.com/tenbaht/sduino/raw/master/package_sduino_stm8_index.json \n  as an Additional Boards Manager URL  Select  sduino  in the Boards Manager list (Tools->Board:...->Boards Manager)  Click on Install   Wait for the download to finsh and you are ready to blink:   Open the Boards list at Tools->Board:...  You should find a new entry \"STM8S Boards\".  Choose  STM8S103F3 Breakout Board  from the list  Open the standard Blink example from File->Examples->01. Basics->Blink  Compile it by hitting 'Verify'   Wasn't too hard, was it?",
            "title": "Using the Arduino Board Manager"
        },
        {
            "location": "/usage/board-manager-install/#manual-install",
            "text": "Only if you prefer a Makefile based build over using the Arduino IDE or if\nyou would like to help with the development of Sduino you will have to do a manual installation  instead.",
            "title": "Manual install"
        },
        {
            "location": "/usage/build-ide/",
            "text": "Building with the Arduino IDE\n\n\nSduino now blends in smoothly with the Arduino IDE. Just choose a matching\nboard type from the list of supported boards at Tools->Board and work as\nusual.\n\n\n\n\nOpen the Boards list at Tools->Board:...\n\n\nYou should find a new entry \"STM8S Boards\".\n\n\nChoose \nSTM8S103F3 Breakout Board\n from the list\n\n\nOpen the standard Blink example from File->Examples->01. Basics->Blink\n\n\nCompile it by clickin 'Verify'\n\n\nOr upload it to the connected board by clicking 'Upload'\n\n\n\n\nDone! Your first STM8 based project is up and running!\n\n\nBut keep in mind that it still based on plain C and not 100% Arduino syntax.\nIt is close enough, that even some of the stock example sketches work right\nout of the box, but others will require small modifications.\n\n\nFIXME: How to access the Sduino adopted example sketches",
            "title": "Building with the IDE"
        },
        {
            "location": "/usage/build-ide/#building-with-the-arduino-ide",
            "text": "Sduino now blends in smoothly with the Arduino IDE. Just choose a matching\nboard type from the list of supported boards at Tools->Board and work as\nusual.   Open the Boards list at Tools->Board:...  You should find a new entry \"STM8S Boards\".  Choose  STM8S103F3 Breakout Board  from the list  Open the standard Blink example from File->Examples->01. Basics->Blink  Compile it by clickin 'Verify'  Or upload it to the connected board by clicking 'Upload'   Done! Your first STM8 based project is up and running!  But keep in mind that it still based on plain C and not 100% Arduino syntax.\nIt is close enough, that even some of the stock example sketches work right\nout of the box, but others will require small modifications.  FIXME: How to access the Sduino adopted example sketches",
            "title": "Building with the Arduino IDE"
        },
        {
            "location": "/usage/why-stm8/",
            "text": "Let's ask the forbidden question:\n\n\nWhy?\n\n\nThe fine line between sense and nonsense.\n\n\nWhen to use an STM8 - and when not\n\n\nHobby applications\n\n\nThe fairly new ESP-14 module includes a STM8S003F3P6: Wifi and a\nprogrammable I/O-CPU for just over two dollars - that might be the most\ncompelling reason to get started on the STM8S series. Apart from pure\ncuriosity and eagerness to learn something new, of course.\n\n\nThe simple STM8S103F breakout boards are powerful and dirt cheap. They cost\nwell under one dollar. You can get three boards and one flash programmer\ntogether for well under five dollars on\n\naliexpress\n,\nincluding shipping from China.\n\n\nThat is an extremely good opportunity to learn something new.\n\n\nThe major downside of this CPU series is the lack of information and\ncommunity support for the STM8. The community support and the sheer number\nof existing libraries for all kinds of sensors and hardware is outstanding\nin the Arduino world. \n\n\nDon't let the tempting price tag be your only guide. An Arduino Nano\ncompatible board is not \nthat\n much more expensive: They start at $1.90 on\n\naliexpress\n.\nThat is only $1.20 more than an STM8S. I am sure you can afford that.\n\n\nIf you just want to get something done, go for an\nArduino board. Nothing will give you faster and easier results.\n\n\n(Or an STM32F103 bluepill for the same price if you need more computing\npower).\n\n\nTinkering and Repurposing\n\n\nThe STM8 series by ST might be the cheapest CPUs on the market while still\nbeing as powerful as the ATmega series. That makes them every Chinese\nengineer's darling and chances are pretty good that you will find an '003 if\nyou crack open any cheap appliance like an irrigation, temperature, or\ncharging controller.\n\n\nThings like the \nW1209 thermostat boards\n\ncould be useful for almost every kind of sensor application. There is plenty\nof cheap stuff around that only needs a different firmware to be used for\nsomething.\n\n\nAnd Sduino might be just the right tool to help you doing this.\n\n\nCommercial applications\n\n\nFor commercial use the STM8S offers some interesting advantages:\n\n\nMotor control\n: The STM8 has a strong focus on motor and position control\nsystems. Things you need to handle yourself on an ATmega are implemented in\nhardware and work independently of the state of the software. There is even\nhardware support for quadrature encoders as used in position sensors and\nrotary encoders.\n\n\nLow power modes\n: The numbers in the datasheets don't look that different,\nbut in real life the STM8 can be powered two or three times longer using the\nsame battery capacity due to the finer control on the power modes (very,\nvery careful programming required).\n\n\nValue for the money\n: 40 to 60 cents for a STM8 with 14 I/O pins compared to\n$1.60-$3.00 for an ATmega8.\n\n\nUpgrade path\n: The peripheral units of the STM8 are identical or at least\nvery, very similar to the ones used with the STM32 family of 32 bit\nARM-Cortex CPUs. This makes it is relatively easy to migrate existing\nsoftware between the 8- and the 32-bit world. This is quite unique among the\nother CPUs.",
            "title": "When to use an STM8S - and when not"
        },
        {
            "location": "/usage/why-stm8/#why",
            "text": "The fine line between sense and nonsense.",
            "title": "Why?"
        },
        {
            "location": "/usage/why-stm8/#when-to-use-an-stm8-and-when-not",
            "text": "Hobby applications  The fairly new ESP-14 module includes a STM8S003F3P6: Wifi and a\nprogrammable I/O-CPU for just over two dollars - that might be the most\ncompelling reason to get started on the STM8S series. Apart from pure\ncuriosity and eagerness to learn something new, of course.  The simple STM8S103F breakout boards are powerful and dirt cheap. They cost\nwell under one dollar. You can get three boards and one flash programmer\ntogether for well under five dollars on aliexpress ,\nincluding shipping from China.  That is an extremely good opportunity to learn something new.  The major downside of this CPU series is the lack of information and\ncommunity support for the STM8. The community support and the sheer number\nof existing libraries for all kinds of sensors and hardware is outstanding\nin the Arduino world.   Don't let the tempting price tag be your only guide. An Arduino Nano\ncompatible board is not  that  much more expensive: They start at $1.90 on aliexpress .\nThat is only $1.20 more than an STM8S. I am sure you can afford that.  If you just want to get something done, go for an\nArduino board. Nothing will give you faster and easier results.  (Or an STM32F103 bluepill for the same price if you need more computing\npower).  Tinkering and Repurposing  The STM8 series by ST might be the cheapest CPUs on the market while still\nbeing as powerful as the ATmega series. That makes them every Chinese\nengineer's darling and chances are pretty good that you will find an '003 if\nyou crack open any cheap appliance like an irrigation, temperature, or\ncharging controller.  Things like the  W1209 thermostat boards \ncould be useful for almost every kind of sensor application. There is plenty\nof cheap stuff around that only needs a different firmware to be used for\nsomething.  And Sduino might be just the right tool to help you doing this.  Commercial applications  For commercial use the STM8S offers some interesting advantages:  Motor control : The STM8 has a strong focus on motor and position control\nsystems. Things you need to handle yourself on an ATmega are implemented in\nhardware and work independently of the state of the software. There is even\nhardware support for quadrature encoders as used in position sensors and\nrotary encoders.  Low power modes : The numbers in the datasheets don't look that different,\nbut in real life the STM8 can be powered two or three times longer using the\nsame battery capacity due to the finer control on the power modes (very,\nvery careful programming required).  Value for the money : 40 to 60 cents for a STM8 with 14 I/O pins compared to\n$1.60-$3.00 for an ATmega8.  Upgrade path : The peripheral units of the STM8 are identical or at least\nvery, very similar to the ones used with the STM32 family of 32 bit\nARM-Cortex CPUs. This makes it is relatively easy to migrate existing\nsoftware between the 8- and the 32-bit world. This is quite unique among the\nother CPUs.",
            "title": "When to use an STM8 - and when not"
        },
        {
            "location": "/usage/manual-install/",
            "text": "Manual Installation\n\n\nThe recommanded way of installation is now the \nautomatic\ninstallation\n using the Arduino Board Manager.\n\n\nThe manual installation described here is only useful if you prefer a\nMakefile based build over using the Arduino IDE or if you would like to help\nwith the development of Sduino.\n\n\nIn any case it is still possible to use the IDE.\n\n\nFor all systems start with this:\n\n\n\n\nClone or download and extract the\n  \nrepository\n to a convenient location.\n\n\nDownload the lastest \nSDCC snapshot\n  build\n for your system. Support for\n  the STM8 improves significantly from version to version. Do not use the\n  older version of SDCC that might be included in your distribution (Version\n  3.6 is definitely too old).\n\n\n\n\nLinux\n\n\nSduino core\n\n\nLink the hardware/sduino folder of the downloaded repository to your local\nArduino hardware folder (usually in \n~/sketchbook\n or \n~/Arduino\n). Create\nthe hardware folder, if not already present:\n\n\n    cd ~/Arduino\n    mkdir hardware  # only if not already present\n    ln -s [the-extracted-repository]/sduino/hardware/sduino hardware\n\n\n\n\nSDCC\n\n\nExtract the downloaded \nSDCC archive\n\nunder \n/opt\n:\n\n\n    sudo mkdir /opt\n    sudo tar xvjf ~/Downloads/sdcc-snapshot* -C /opt\n\n\n\n\nCreate a link to SDCC from the tools directory of the sduino repository\n(required for IDE builds):\n\n\n    cd ~/Arduino/hardware/sduino/tools\n    ln -s /opt/sdcc .\n\n\n\n\nFlashtools\n\n\nstm8flash\n and \nstm8gal\n are both included as precompiled binaries in this\ntools directory. Create a link \nlinux\n to the linux tools directory that\nmatches your system and copy the binaries to a convient place in your path,\ne.g. \n/usr/local/bin\n:\n\n\n    ln -s linux64 linux\n    cp -av linux/* /usr/local/bin\n\n\n\n\nmake\n and libusb-1.0 (needed by stm8flash) are part of the standard\nrepository for any Linux distribution. Example for Debian-type systems (like\nUbuntu, Mint, Elementary etc.):\n\n\n    sudo apt-get install make libusb-1.0-0\n\n\n\n\nFinally, add a udev rule in order to access the USB port for your flash\ntool. Save this as root in in \n/etc/udev/rules.d/99-stlink.rules\n:\n\n\n    # ST-Link/V2 programming adapter\n\n    # ST-Link V1, if using a STM8S discovery board\n    # important: It needs a special entry in /etc/modprobe.d\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n    # ST-Link/V2, the china adapter with the green plastic housing\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"\n\n\n\n\nUsing the STM8S-Discovery board as a flash programmer requires a \nspecial\nmodprobe configuration\nentry\n.\n\n\nMacOS\n\n\nQuite similar to the Linux install. \nInstall Homebrew\n if\nyou haven't done it yet, than install make and unpack the sdcc snapshot:\n\n\n    brew make\n    mkdir /opt\n    tar xvjf sdcc-snapshot* -C /opt\n\n\n\n\nAdopt the other steps from the Linux install. The arduino hardware folder is\nin your Documents folder at \n/Users/<username>/Documents/Arduino/hardware\n.\n\n\nNot sure about stm8flash, I didn't try it. Have a look at the \nstm8flash\nrepository\n. It would be great if\nsomeone could summarize the procedure and send it to me together with a\ncompiled binary for the repository.\n\n\nWindows\n\n\nSame idea again, but additionally we need to install a minimal MinGW command\nline environment with tools needed by make and the Makefile. Let's start\nwith that:\n\n\nInstall Msys2\n\n\n\n\nDownload and run the installer from \nhttp://www.msys2.org\n\n\nInstall make: \npacman -S make\n\n\ndefine the environment variable \nHOME\n in the windows settings as\n  \n%USERPROFILE%\n\n\nclose and re-open the terminal window\n\n\n\n\nNow we can start working. \n\n\nInstall the core files and SDCC\n\n\nThanks to the running bash the remaining steps are the same as for Linux,\nthe only difference is your Arduino folder in \nDocuments/Arduino\n.\n\n\nST-Link, stm8flash\n\n\nIf not already done, install the ST-Link driver from the ST website for\nhardware access.\n\n\nYou are not bound to \nstm8flash\n, you can use the regular flash tool by ST\nif you prefer.\n\n\nstm8flash\n and \nlibusb-1.0.dll\n are both included as precompiled binaries\nin the tools directory. Copy or link them to a directory in your path:\n\n\n    cd hardware/sduino/tools/win\n    cp -av stm8flash.exe libusb-1.0.dll /bin\n\n\n\n\nLimitations\n\n\nKeep the \nknown problems using\nWindows\n in mind.\n\n\nAdditional suggestions for Windows users\n\n\nGet a better console\n\n\nThere is no good reason to keep suffering from the stock Windows terminal\nwindow. Installing e.g.\n\nconsole2\n will make your life on\nthe command line so much more enjoyable.\n\n\nInstallation shortcut\n\n\nInstead of installing mingw and sdcc from scratch you can\n\n\n\n\nmanually unpack the latest board manager tools archive\n  \nsduino-tools_mingw32*.tar.bz2\n\n  into the hardware/sduino/tools folder\n\n\nset \nc:\\sdcc\n as a link to the sdcc folder\n\n\nAdd \ntools/win\n and \nc:\\sdcc\\bin\n to your `%PATH%\n\n\n\n\nAs a workaround for unpacking a tar.bz2 file (again, Windows is lacking even\nthe most basic tools...) you could use the board manager and copy the needed\nfiles out of Appdata/Arduino/packages/sduino. But mind the slightly\ndifferent directory layout and don't forget to remove the package again\nafter you are done copying. Otherwise your are going to use different\nversions of the sduino core for IDE and Makefile builds. Confusion would be\nguaranteed!\n\n\nUsing MinGW instead of msys2\n\n\nI used to recommand using MinGW, because it is more compact than msys2. But\ninstallation is a little more complicated. If you are like me and prefer\nminimal solutions over big packages:\n\n\n\n\nCheck the\n   \nMinGW Installation Notes\n\n\nDownload and run\n   \nmingw-get-setup.exe\n\n   You can safely deactivate the graphical option.\n\n\nAdd \n;c:\\mingw\\bin;c:\\mingw\\msys\\1.0\\bin\n to the end of your \n%PATH%\n\n\nOpen a command line and install msys-base: \nmingw-get install msys-base\n\n\nNow \nls\n or \nmake\n should work.\n\n\nStart a bash: \nbash\n\n\nFor now you might want to set the \nHOME\n variable: \nexport\n   HOME=/c/Users/<yourusername>\n. In the long run this goes in \n.bashrc\n.\n\n\n\n\nAdditional general tweaks\n\n\nThe full SDCC archive includes support for many CPUs, but you only need the\nstm8. You can safely delete all the files related to the PIC CPUs in the\n\npic*\n and \nnon-free\n directories. That safes more than 90% of the used disk\nspace and leaves only 20MB out of 240MB.",
            "title": "Manual Installation"
        },
        {
            "location": "/usage/manual-install/#manual-installation",
            "text": "The recommanded way of installation is now the  automatic\ninstallation  using the Arduino Board Manager.  The manual installation described here is only useful if you prefer a\nMakefile based build over using the Arduino IDE or if you would like to help\nwith the development of Sduino.  In any case it is still possible to use the IDE.  For all systems start with this:   Clone or download and extract the\n   repository  to a convenient location.  Download the lastest  SDCC snapshot\n  build  for your system. Support for\n  the STM8 improves significantly from version to version. Do not use the\n  older version of SDCC that might be included in your distribution (Version\n  3.6 is definitely too old).",
            "title": "Manual Installation"
        },
        {
            "location": "/usage/manual-install/#linux",
            "text": "Sduino core  Link the hardware/sduino folder of the downloaded repository to your local\nArduino hardware folder (usually in  ~/sketchbook  or  ~/Arduino ). Create\nthe hardware folder, if not already present:      cd ~/Arduino\n    mkdir hardware  # only if not already present\n    ln -s [the-extracted-repository]/sduino/hardware/sduino hardware  SDCC  Extract the downloaded  SDCC archive \nunder  /opt :      sudo mkdir /opt\n    sudo tar xvjf ~/Downloads/sdcc-snapshot* -C /opt  Create a link to SDCC from the tools directory of the sduino repository\n(required for IDE builds):      cd ~/Arduino/hardware/sduino/tools\n    ln -s /opt/sdcc .  Flashtools  stm8flash  and  stm8gal  are both included as precompiled binaries in this\ntools directory. Create a link  linux  to the linux tools directory that\nmatches your system and copy the binaries to a convient place in your path,\ne.g.  /usr/local/bin :      ln -s linux64 linux\n    cp -av linux/* /usr/local/bin  make  and libusb-1.0 (needed by stm8flash) are part of the standard\nrepository for any Linux distribution. Example for Debian-type systems (like\nUbuntu, Mint, Elementary etc.):      sudo apt-get install make libusb-1.0-0  Finally, add a udev rule in order to access the USB port for your flash\ntool. Save this as root in in  /etc/udev/rules.d/99-stlink.rules :      # ST-Link/V2 programming adapter\n\n    # ST-Link V1, if using a STM8S discovery board\n    # important: It needs a special entry in /etc/modprobe.d\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n    # ST-Link/V2, the china adapter with the green plastic housing\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"  Using the STM8S-Discovery board as a flash programmer requires a  special\nmodprobe configuration\nentry .",
            "title": "Linux"
        },
        {
            "location": "/usage/manual-install/#macos",
            "text": "Quite similar to the Linux install.  Install Homebrew  if\nyou haven't done it yet, than install make and unpack the sdcc snapshot:      brew make\n    mkdir /opt\n    tar xvjf sdcc-snapshot* -C /opt  Adopt the other steps from the Linux install. The arduino hardware folder is\nin your Documents folder at  /Users/<username>/Documents/Arduino/hardware .  Not sure about stm8flash, I didn't try it. Have a look at the  stm8flash\nrepository . It would be great if\nsomeone could summarize the procedure and send it to me together with a\ncompiled binary for the repository.",
            "title": "MacOS"
        },
        {
            "location": "/usage/manual-install/#windows",
            "text": "Same idea again, but additionally we need to install a minimal MinGW command\nline environment with tools needed by make and the Makefile. Let's start\nwith that:  Install Msys2   Download and run the installer from  http://www.msys2.org  Install make:  pacman -S make  define the environment variable  HOME  in the windows settings as\n   %USERPROFILE%  close and re-open the terminal window   Now we can start working.   Install the core files and SDCC  Thanks to the running bash the remaining steps are the same as for Linux,\nthe only difference is your Arduino folder in  Documents/Arduino .  ST-Link, stm8flash  If not already done, install the ST-Link driver from the ST website for\nhardware access.  You are not bound to  stm8flash , you can use the regular flash tool by ST\nif you prefer.  stm8flash  and  libusb-1.0.dll  are both included as precompiled binaries\nin the tools directory. Copy or link them to a directory in your path:      cd hardware/sduino/tools/win\n    cp -av stm8flash.exe libusb-1.0.dll /bin  Limitations  Keep the  known problems using\nWindows  in mind.",
            "title": "Windows"
        },
        {
            "location": "/usage/manual-install/#additional-suggestions-for-windows-users",
            "text": "Get a better console  There is no good reason to keep suffering from the stock Windows terminal\nwindow. Installing e.g. console2  will make your life on\nthe command line so much more enjoyable.  Installation shortcut  Instead of installing mingw and sdcc from scratch you can   manually unpack the latest board manager tools archive\n   sduino-tools_mingw32*.tar.bz2 \n  into the hardware/sduino/tools folder  set  c:\\sdcc  as a link to the sdcc folder  Add  tools/win  and  c:\\sdcc\\bin  to your `%PATH%   As a workaround for unpacking a tar.bz2 file (again, Windows is lacking even\nthe most basic tools...) you could use the board manager and copy the needed\nfiles out of Appdata/Arduino/packages/sduino. But mind the slightly\ndifferent directory layout and don't forget to remove the package again\nafter you are done copying. Otherwise your are going to use different\nversions of the sduino core for IDE and Makefile builds. Confusion would be\nguaranteed!  Using MinGW instead of msys2  I used to recommand using MinGW, because it is more compact than msys2. But\ninstallation is a little more complicated. If you are like me and prefer\nminimal solutions over big packages:   Check the\n    MinGW Installation Notes  Download and run\n    mingw-get-setup.exe \n   You can safely deactivate the graphical option.  Add  ;c:\\mingw\\bin;c:\\mingw\\msys\\1.0\\bin  to the end of your  %PATH%  Open a command line and install msys-base:  mingw-get install msys-base  Now  ls  or  make  should work.  Start a bash:  bash  For now you might want to set the  HOME  variable:  export\n   HOME=/c/Users/<yourusername> . In the long run this goes in  .bashrc .",
            "title": "Additional suggestions for Windows users"
        },
        {
            "location": "/usage/manual-install/#additional-general-tweaks",
            "text": "The full SDCC archive includes support for many CPUs, but you only need the\nstm8. You can safely delete all the files related to the PIC CPUs in the pic*  and  non-free  directories. That safes more than 90% of the used disk\nspace and leaves only 20MB out of 240MB.",
            "title": "Additional general tweaks"
        },
        {
            "location": "/usage/build-cli/",
            "text": "Building with the Makefile\n\n\nA preconfigured IDE is a great way to start, but sooner or later you will\nwant more control and flexibility.\n\n\nThe \nmanual install\n of Sduino comes with an easy-to-use powerful\nMakefile based on the amazing \nArduino.mk\nmakefile\n by\n\nSudar\n.\n\n\nLet's blink an LED using the Blink example from Arduino:\n\n\n/*\n  Blink\n  Turns on an LED on for one second, then off for one second, repeatedly.\n\n  This example code is in the public domain.\n*/\n\n#include <Arduino.h>\n\n// Pin 13 has an LED connected on most Arduino boards.\n// Pin 3 for the STM8S103 break out board\n// give it a name:\nint led = LED_BUILTIN;\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize the digital pin as an output.\n  pinMode(led, OUTPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);               // wait for a second\n}\n\n\n\n\nAll we need for a full build is this very basic \nMakefile\n (adopt the path\nof the include statement for your situation):\n\n\nBOARD_TAG   = stm8sblue\n\ninclude ../../sduino/sduino.mk\n\n\n\n\nCompile and upload it:\n\n\nmake upload\n\n\n\nDone! Your first STM8 based project is up and running!",
            "title": "Building with a Makefile"
        },
        {
            "location": "/usage/build-cli/#building-with-the-makefile",
            "text": "A preconfigured IDE is a great way to start, but sooner or later you will\nwant more control and flexibility.  The  manual install  of Sduino comes with an easy-to-use powerful\nMakefile based on the amazing  Arduino.mk\nmakefile  by Sudar .  Let's blink an LED using the Blink example from Arduino:  /*\n  Blink\n  Turns on an LED on for one second, then off for one second, repeatedly.\n\n  This example code is in the public domain.\n*/\n\n#include <Arduino.h>\n\n// Pin 13 has an LED connected on most Arduino boards.\n// Pin 3 for the STM8S103 break out board\n// give it a name:\nint led = LED_BUILTIN;\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // initialize the digital pin as an output.\n  pinMode(led, OUTPUT);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);               // wait for a second\n  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);               // wait for a second\n}  All we need for a full build is this very basic  Makefile  (adopt the path\nof the include statement for your situation):  BOARD_TAG   = stm8sblue\n\ninclude ../../sduino/sduino.mk  Compile and upload it:  make upload  Done! Your first STM8 based project is up and running!",
            "title": "Building with the Makefile"
        },
        {
            "location": "/usage/limitations/",
            "text": "Limitations\n\n\nCompatibility with the Arduino world\n\n\nI adopted the Arduino core functionality for the STM8S to set up a simple\nprogramming environment. But unfortunatly there is no free C++ compiler for\nthese CPUs. This makes it impossible to do a full port of the whole\nenviroment and integrate it 100% in the Arduino world as it has been done\nfor the STM32 and the ESP8266.\n\n\nThis is not a drop-in replacement for an AVR, but the programming API is\nstill very, very similar. Adopting existing libraries from C++ to C for use\nwith the simplified C API is often easy and can be done quite fast,\ndepending on the degree of dependency on specific hardware features.\n\n\nUsing a converter/compiler like\n\ncfront\n to translate from C++ to C\nmight be an option.\n\n\nFloat arithmetics\n\n\nFloating point arithmetics is supported by the SDCC standard library, but it\ncomes at a pretty high cost in terms of code space and CPU load. This is how\nmuch the generated code grows by using a single float operation compared to \nusing a long int:\n\n\n\n\n\n\n\n\nFloating point operation\n\n\napprox. code size\n\n\n\n\n\n\n\n\n\n\naddition\n\n\n736 Bytes\n\n\n\n\n\n\nsubtraction\n\n\n754 Bytes\n\n\n\n\n\n\ndivision\n\n\n673 Bytes\n\n\n\n\n\n\nmultiplication\n\n\n907 Bytes\n\n\n\n\n\n\nsinf() or cosf()\n\n\n3346 Bytes\n\n\n\n\n\n\nlog10f()\n\n\n3437 Bytes\n\n\n\n\n\n\n\n\nThe Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple\nsimple program with only very little floating point arithmetics. But it\nalready uses 7336 bytes of flash. A similar sketch using integer arithmetics\nresults in much more compact code occuping only 3791 bytes.\n\n\nFloat does work, but is better to be avoided and replaced by fixed point\narithmetics whenever possible.\n\n\nKnown problems using Windows\n\n\nIt works, but using the Arduino.mk makefile with Windows is slow. \nVery\n\nslow. Painfully slow. Compiling-the-Blink-example-takes-about-40-seconds\nkind of slow. Yes, seriously. No kidding. 40 seconds. Measured on a 3GHz\nmachine with 4GB RAM.\n\n\nThere is no easy fix, the underlying problem is a fundamental one. It is not\nabout the compilation itself, it is the way Makefiles are written and\nexecuted. The whole concept relies on forking subprocesses for all the shell\ncalls. Unfortunately, there is nothing like a fork in Windows and to work\naround that is painfully slow.\n\n\nIt would be great if somebody would replace the painfully slow parameter\nchecking part of the makefile (that causes the majority of forking) by a\nsingle shell script that gets called by the makefile and delivers the\nresults in no time. Or use \ncmake\n. Or integrate it somehow\ninto the STVD IDE (This \nSTVD-SDCC integration\nsuite\n might be useful). Or\nwhatever.\n\n\nUntil then the least annoying way out might be using a virtual machine\nrunning a simple Linux system. Ubuntu Mate or a basic Debian install for\nexample. Virtual Box is great for this purpose and freely available. The new\nLinux Subsystem feature of Windows 10 might be another option.",
            "title": "Limitations"
        },
        {
            "location": "/usage/limitations/#limitations",
            "text": "",
            "title": "Limitations"
        },
        {
            "location": "/usage/limitations/#compatibility-with-the-arduino-world",
            "text": "I adopted the Arduino core functionality for the STM8S to set up a simple\nprogramming environment. But unfortunatly there is no free C++ compiler for\nthese CPUs. This makes it impossible to do a full port of the whole\nenviroment and integrate it 100% in the Arduino world as it has been done\nfor the STM32 and the ESP8266.  This is not a drop-in replacement for an AVR, but the programming API is\nstill very, very similar. Adopting existing libraries from C++ to C for use\nwith the simplified C API is often easy and can be done quite fast,\ndepending on the degree of dependency on specific hardware features.  Using a converter/compiler like cfront  to translate from C++ to C\nmight be an option.",
            "title": "Compatibility with the Arduino world"
        },
        {
            "location": "/usage/limitations/#float-arithmetics",
            "text": "Floating point arithmetics is supported by the SDCC standard library, but it\ncomes at a pretty high cost in terms of code space and CPU load. This is how\nmuch the generated code grows by using a single float operation compared to \nusing a long int:     Floating point operation  approx. code size      addition  736 Bytes    subtraction  754 Bytes    division  673 Bytes    multiplication  907 Bytes    sinf() or cosf()  3346 Bytes    log10f()  3437 Bytes     The Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple\nsimple program with only very little floating point arithmetics. But it\nalready uses 7336 bytes of flash. A similar sketch using integer arithmetics\nresults in much more compact code occuping only 3791 bytes.  Float does work, but is better to be avoided and replaced by fixed point\narithmetics whenever possible.",
            "title": "Float arithmetics"
        },
        {
            "location": "/usage/limitations/#known-problems-using-windows",
            "text": "It works, but using the Arduino.mk makefile with Windows is slow.  Very \nslow. Painfully slow. Compiling-the-Blink-example-takes-about-40-seconds\nkind of slow. Yes, seriously. No kidding. 40 seconds. Measured on a 3GHz\nmachine with 4GB RAM.  There is no easy fix, the underlying problem is a fundamental one. It is not\nabout the compilation itself, it is the way Makefiles are written and\nexecuted. The whole concept relies on forking subprocesses for all the shell\ncalls. Unfortunately, there is nothing like a fork in Windows and to work\naround that is painfully slow.  It would be great if somebody would replace the painfully slow parameter\nchecking part of the makefile (that causes the majority of forking) by a\nsingle shell script that gets called by the makefile and delivers the\nresults in no time. Or use  cmake . Or integrate it somehow\ninto the STVD IDE (This  STVD-SDCC integration\nsuite  might be useful). Or\nwhatever.  Until then the least annoying way out might be using a virtual machine\nrunning a simple Linux system. Ubuntu Mate or a basic Debian install for\nexample. Virtual Box is great for this purpose and freely available. The new\nLinux Subsystem feature of Windows 10 might be another option.",
            "title": "Known problems using Windows"
        },
        {
            "location": "/usage/status-todo/",
            "text": "Status and Todo\n\n\nCurrent status\n\n\ntested and working\n\n\n\n\npinMode()\n\n\ndigitalWrite()\n\n\nanalogRead()\n\n\ndelay()\n\n\nanalogWrite()\n\n\nShiftOut()\n\n\nWMath: \nmap()\n\n\nserialEvent()\n\n\npulseInLong()\n\n\nHardwareSerial\n:\n  Standard UART interface with Print functions\n\n\nPrint\n:\n  Formatting functions to be used with the other output libraries\n\n\nSPI\n:\n  working, no interrupt support  \n\n\nLiquidCrystal\n:\n  Text LCD based on the HD44780 controller  \n\n\nPCD8544\n:\n  Nokia 5110 type displays  \n\n\nMini_SSD1306\n:\n  Monochrome OLED displays based on the SSD1306 controller\n\n\nStepper\n:\n  Multi-instance design for more than one stepper at a time  \n\n\nServo\n:\n  Multi-instance design for more than one servo at a time)  \n\n\n\n\nimplemented and partly working\n\n\n\n\nWire/I2C\n\n\n\n\ntested, but not working\n\n\n\n\nalternateFunctions()\n\n\n\n\nnot tested\n\n\n\n\nShiftIn()\n\n\nrandom()\n\n\nsrandom()\n\n\n\n\nnot implemented\n\n\n\n\ntone()\n\n\nnoTone()\n\n\npulseIn()\n\n\nmodule WCharacter\n\n\nmodule WString\n\n\n\n\nTodo\n\n\nInteresting libraries that might be worth porting\n\n\ncI2C\n: Arduino Hardware I2C for AVR\n(plain c)\n\n\nSimpleDHT\n: Simple, Stable and\nFast Arduino Temp & Humidity Sensors for DHT11 and DHT22. It started out\nas plain C code (v1.0.0), but was converted to (simple) C++ with v1.0.1\n\n\ncQueue\n: Queue handling library\n(written in plain c). But maybe too high-level to be worth using on very\nsmall devices.\n\n\nRTCtime\n: This library makes\nusing modules based on the DS1307 and DS3231 RTC really easy. It is\ncompatible with and is meant to leverage the standard C time library\n\ntime.h\n API (datatypes and functions) as defined in ISO/IEC 9899 (C90) and\nimplemented in the AVR Std C runtime libray since version 2.0.0.\n\n\nFatFS\n: FatFs is a generic FAT\nfile system module for small embedded systems. The FatFs is written in\ncompliance with ANSI C and completely separated from the disk I/O layer.\nTherefore it is independent of hardware architecture.\nstm32duino port of \nFatFS by\nelm-chan\n. A stripped down\nversion exists as \nPetit FAT File System\nModule\n for very small CPU. Only\n2..4kB flash usage.\n\n\nUnresolved problems\n\n\nThe compile environment needs to detect which interrupts are actively used\nand link only the needed ones into the binary. See test/digitalWrite:\nCompiling with the straight Makefile.classic does not add UART interrupt\nroutines. But when using the sduino.mk Makefile the two UART interrupt\nroutines are pulled into the binary by the interrupt table in main.c.",
            "title": "Status and todo"
        },
        {
            "location": "/usage/status-todo/#status-and-todo",
            "text": "",
            "title": "Status and Todo"
        },
        {
            "location": "/usage/status-todo/#current-status",
            "text": "tested and working   pinMode()  digitalWrite()  analogRead()  delay()  analogWrite()  ShiftOut()  WMath:  map()  serialEvent()  pulseInLong()  HardwareSerial :\n  Standard UART interface with Print functions  Print :\n  Formatting functions to be used with the other output libraries  SPI :\n  working, no interrupt support    LiquidCrystal :\n  Text LCD based on the HD44780 controller    PCD8544 :\n  Nokia 5110 type displays    Mini_SSD1306 :\n  Monochrome OLED displays based on the SSD1306 controller  Stepper :\n  Multi-instance design for more than one stepper at a time    Servo :\n  Multi-instance design for more than one servo at a time)     implemented and partly working   Wire/I2C   tested, but not working   alternateFunctions()   not tested   ShiftIn()  random()  srandom()   not implemented   tone()  noTone()  pulseIn()  module WCharacter  module WString",
            "title": "Current status"
        },
        {
            "location": "/usage/status-todo/#todo",
            "text": "Interesting libraries that might be worth porting  cI2C : Arduino Hardware I2C for AVR\n(plain c)  SimpleDHT : Simple, Stable and\nFast Arduino Temp & Humidity Sensors for DHT11 and DHT22. It started out\nas plain C code (v1.0.0), but was converted to (simple) C++ with v1.0.1  cQueue : Queue handling library\n(written in plain c). But maybe too high-level to be worth using on very\nsmall devices.  RTCtime : This library makes\nusing modules based on the DS1307 and DS3231 RTC really easy. It is\ncompatible with and is meant to leverage the standard C time library time.h  API (datatypes and functions) as defined in ISO/IEC 9899 (C90) and\nimplemented in the AVR Std C runtime libray since version 2.0.0.  FatFS : FatFs is a generic FAT\nfile system module for small embedded systems. The FatFs is written in\ncompliance with ANSI C and completely separated from the disk I/O layer.\nTherefore it is independent of hardware architecture.\nstm32duino port of  FatFS by\nelm-chan . A stripped down\nversion exists as  Petit FAT File System\nModule  for very small CPU. Only\n2..4kB flash usage.  Unresolved problems  The compile environment needs to detect which interrupts are actively used\nand link only the needed ones into the binary. See test/digitalWrite:\nCompiling with the straight Makefile.classic does not add UART interrupt\nroutines. But when using the sduino.mk Makefile the two UART interrupt\nroutines are pulled into the binary by the interrupt table in main.c.",
            "title": "Todo"
        },
        {
            "location": "/api/migration/",
            "text": "Migrating existing code from C++ to C syntax\n\n\nThe original Arduino environment uses C++ syntax while sduino can only use\nplain C syntax. Luckily, not many C++ features are used and in most cases a\nconversion is not very hard. In most cases a conversion from C++ to C it is\njust a matter of exchanging a dot for an underscore:\n\n\nA C++ method name \nclass.method()\n becomes a C function name \nclass_method()\n.\n\n\nThis is possible since most libraries are written to be used as a singleton\nanyway, so the fixed name prefix is not a problem. Only very few libraries\nneed a slightly more complex approach to be able to deal with multiple\ninstances.\n\n\nThere are two bigger problems left:\n\n\nPolymorph functions\n\n\nThe concept of polymorphism does not exist for plain C. As a workaround\n'mangled' function names are used for the different parameter type\ncombinations supported by the original polymorph methods.\n\n\nTypical name extensions are: \n_u\n for unsigned values, \n_i\n for signed\ninteger values, \n_c\nfor characters, \n_s\n for strings, \n_n\n for data\nbuffer/length combinations.\n\n\nFor more non-regular polymorphism the name extension is often related to the\ndifferent use cases or to the names of the given parameters. Refer to the\nrespective library header file for details.\n\n\nSome examples of typical name changes:\n\n\n\n\n\n\n\n\nC++ name\n\n\nC name\n\n\n\n\n\n\n\n\n\n\nSerial.print(int)\n\n\nSerial_print_i\n\n\n\n\n\n\nSerial.print(unsigned)\n\n\nSerial_print_u\n\n\n\n\n\n\nSerial.print(float)\n\n\nSerial_print_f\n\n\n\n\n\n\nSerial.print(char)\n\n\nSerial_print_c\n\n\n\n\n\n\nSerial.print(char *)\n\n\nSerial_print_s\n\n\n\n\n\n\nSerial.print(char *buf, int len)\n\n\nSerial_print_n\n\n\n\n\n\n\nSerial.print(unsigned n, int base)\n\n\nSerial_print_ub\n\n\n\n\n\n\nrandom(long)\n\n\nrandom\n\n\n\n\n\n\nrandom(long howsmall, long howbig)\n\n\nrandom_minmax\n\n\n\n\n\n\n\n\nThe _Generic selection\n\n\nThe C11 standard introduced the\n\n_Generic\n\nselection function. This function allows for automatic selection of\ndifferent function variants at compile time depending on the type of the\nfunction arguments mimicing polymorph C++ functions.\n\n\nRecent versions of SDCC already support this function (command line argument\n\n--std-sdcc99\n), but it's usefulness is still limited to some special cases.\n\n\n#define Serial_print(X) _Generic((X), \\\n    char*: Serial_print_s, \\\n    signed long: Serial_print_i, \\\n    signed int: Serial_print_i, \\\n    signed char: Serial_print_c, \\\n    unsigned long: Serial_print_u, \\\n    unsigned int: Serial_print_u, \\\n    unsigned char: Serial_print_u \\\n    )(X)\n\n\n\n\nThis would unify some, but not all print function variants:\n\n\n\n\n\n\n\n\nC++ name\n\n\nC name using _Generic\n\n\n\n\n\n\n\n\n\n\nSerial.print(int)\n\n\nSerial_print\n\n\n\n\n\n\nSerial.print(unsigned)\n\n\nSerial_print\n\n\n\n\n\n\nSerial.print(char)\n\n\nSerial_print\n\n\n\n\n\n\nSerial.print(char *)\n\n\nSerial_print_s\n\n\n\n\n\n\nSerial.print(char *buf, int len)\n\n\nSerial_print_n\n\n\n\n\n\n\nSerial.print(unsigned n, int base)\n\n\nSerial_print_ub\n\n\n\n\n\n\n\n\nUnfortunately cpp does not match string constants and \nchar*\n resulting in a\nvery non-regular usage pattern:\n\n\nchar *string=\"Hello\";\n\nSerial_print(string);   // works\nSerial_print(\"Hello\");  // doesn't work\nSerial_print_s(\"Hello\");// works\n\n\n\nTo avoid too much confusion it might be better to not use \n_Generic\n at all.\n\n\nAnother problem using the \n_Generic\n selector is configurable instance\nnames. The preprocessor does not allow for variable macro names. That means\n\n_Generic\n would work with fixed name like \nSerial\n, but it wouldn't work\nfor \nSoftwareSerial\n with no standard instance name.\n\n\nInheritance from Print class\n\n\nMost character output modules inherit methods from the Print class by\nproviding a virtual write method. A similar result can be achived by\nproviding a function pointer to the write function to be used to the print\nfunctions.\n\n\nThis additional parameter is hidden from the user by providing more\nconvinient defines in every library that need to 'inherit' functions from\nPrint. This way \nlcd.print(\"Hello World!\")\n becomes \nlcd_print_s(\"Hello\nWorld!\")\n and \nSerial.print(\"Hello World!\")\n becomes \nSerial_print_s(\"Hello\nWorld!\")\n. Both call the same code from Print, but with different function\npointers to their own putchar/write function.\n\n\nLibraries with multiple instances\n\n\nIf multiple instances need to be supported, an approach similar to a C file\ndescriptor is used. The \"constructor\" function allocates and initializes a\ndata structure for one particular instance and return a pointer to this\nstructure. Typically, this is done in the \nsetup()\n-function and this pointer \nis stored in a global variable to be used as a device descriptor.\n\n\nSo far the \nStepper library\n is the only example:\n\n\n#include <Stepper.h>\nStepper myStepper;      // variable to store the \"device descriptor\"\nvoid setup(void) {\n    myStepper = Stepper_2phase(100,11,12);  // init a 2 phase stepper\n}\nvoid loop() {\n    Stepper_step(myStepper, 20);        // do 20 steps forward\n}\n\n\n\n\nDifferences from the original Arduino environment\n\n\nAdditional output pin modes\n\n\n\n\n\n\n\n\nPin mode\n\n\nPin properties\n\n\n\n\n\n\n\n\n\n\nOUTPUT\n\n\noutput, push-pull, slow mode (default)\n\n\n\n\n\n\nOUTPUT_OD\n\n\noutput, open drain, fast mode\n\n\n\n\n\n\nOUTPUT_FAST\n\n\noutput, push-pull, fast mode\n\n\n\n\n\n\nOUTPUT_OD_FAST\n\n\noutput, open drain, fast mode\n\n\n\n\n\n\n\n\nTimer\n\n\nmillis()\n uses timer4. The prescaler and end value is calculated at compile\ntime for a cycle time as close to 1ms as possible. Default values @16Mhz:\nprescaler=64, counter cycle=250 (end value=249), resulting in exactly 1ms\nintervals.\n\n\ntimer1: PWM for PC3, PC4, on alternate mapping PC6, PC7, could be used for ADC\n\ntimer2: PWM for PA3, PD3, PD4 or PC5 (mutual exclusive)\n\ntimer4: millis()  \n\n\nLeaving out unused parts\n\n\nSome functions of the core Arduino system can be left out on compilation to\nsave code space. This is done by compiler flags that can be defined in the\nMakefile:\n\n\nBOARD_TAG = stm8sblue\nCFLAGS = -DNO_SERIAL -DNO_ANALOG_IN -DNO_ANALOG_OUT\n\ninclude ../../../sduino.mk\n\n\n\n\nThese flags are supported:\n\n\n\n\n\n\n\n\nFlag\n\n\nBytes saved\n\n\nFunctions lost\n\n\n\n\n\n\n\n\n\n\nNO_SERIAL\n\n\n765\n\n\nall serial communication\n\n\n\n\n\n\nNO_ANALOG_OUT\n\n\n406\n\n\nanalogWrite()\n\n\n\n\n\n\nNO_ANALOG_IN\n\n\n56\n\n\nanalogRead()\n\n\n\n\n\n\n\n\nOther modifications\n\n\nmakeWord(unsigned char, unsigned char)\n is an inline function now.\n\n\nAdditional compile-time flags\n\n\nSome internal details can be influenced by setting compile-time defines\nusing the \nCFLAGS=-Dflagname\n line in the Makefile.\n\n\nSUPPORT_ALTERNATE_MAPPINGS\n:\nAllow the use of \nalternateFunctions()\n\n\nENABLE_SWIM\n:\nDo not disable the remote debugging function on the SWIM pin. This means\nthat this pin can not be used for normal I/O functions.\n\n\nUSE_SPL\n:\nUse SPL functions for I/O access instead of direct register accesses. Useful\nonly for debugging and porting to other CPU variants. Do not use for regular\ndevelopment.\n\n\nGeneral notes on the Arduino port\n\n\nADC\n\n\nthe prescaler is initialised for an ADC clock in the range of 1..2 MHz. The\nminimum prescaler value is 2, so for a clock speed of less than 2 MHz the\nrequired minimum ADC clock frequency can not be reached anymore.\n\n\nMapping of logical pin numbers to register addresses\n\n\nThe lookup-table approach for assigning port and bit adresses to the logical\npin numbers is not effient on the STM8. The hole system could be changed to\na more regular scheme and replace the tables by hardcoded adress\ncalculations.\n\n\nInefficient compilation\n\n\ndigitalWrite\n compiles very ineffiently. It might be worth some hand\noptimization.\n\n\nAccessing the alternate pin functions\n\n\nAdded \nalternateFunction()\n to allow switching of some pins to their alternate\nfunctions. This allows for three more PWM pins, but maybe it adds to much\ncomplexity for the Arduino API. Not sure if it should stay. Has to be\nenabled by defining \nSUPPORT_ALTERNATE_MAPPINGS\n.\n\n\nUseful CPU features that are not supported by the Arduino API\n\n\nInput-Capture-Mode:\n Available for all four channels, at least for\ntimer1. Would be great for precise time measurements. Maybe build a library?\n\n\nEncoder interface mode:\n Hardware support for reading quadrature encoder\nand keeping track of the current (motor) position using a hardware timer\ncounter. Perfectly suited to all kinds of position feedback.",
            "title": "API description and migration guidelines"
        },
        {
            "location": "/api/migration/#migrating-existing-code-from-c-to-c-syntax",
            "text": "The original Arduino environment uses C++ syntax while sduino can only use\nplain C syntax. Luckily, not many C++ features are used and in most cases a\nconversion is not very hard. In most cases a conversion from C++ to C it is\njust a matter of exchanging a dot for an underscore:  A C++ method name  class.method()  becomes a C function name  class_method() .  This is possible since most libraries are written to be used as a singleton\nanyway, so the fixed name prefix is not a problem. Only very few libraries\nneed a slightly more complex approach to be able to deal with multiple\ninstances.  There are two bigger problems left:",
            "title": "Migrating existing code from C++ to C syntax"
        },
        {
            "location": "/api/migration/#polymorph-functions",
            "text": "The concept of polymorphism does not exist for plain C. As a workaround\n'mangled' function names are used for the different parameter type\ncombinations supported by the original polymorph methods.  Typical name extensions are:  _u  for unsigned values,  _i  for signed\ninteger values,  _c for characters,  _s  for strings,  _n  for data\nbuffer/length combinations.  For more non-regular polymorphism the name extension is often related to the\ndifferent use cases or to the names of the given parameters. Refer to the\nrespective library header file for details.  Some examples of typical name changes:     C++ name  C name      Serial.print(int)  Serial_print_i    Serial.print(unsigned)  Serial_print_u    Serial.print(float)  Serial_print_f    Serial.print(char)  Serial_print_c    Serial.print(char *)  Serial_print_s    Serial.print(char *buf, int len)  Serial_print_n    Serial.print(unsigned n, int base)  Serial_print_ub    random(long)  random    random(long howsmall, long howbig)  random_minmax     The _Generic selection  The C11 standard introduced the _Generic \nselection function. This function allows for automatic selection of\ndifferent function variants at compile time depending on the type of the\nfunction arguments mimicing polymorph C++ functions.  Recent versions of SDCC already support this function (command line argument --std-sdcc99 ), but it's usefulness is still limited to some special cases.  #define Serial_print(X) _Generic((X), \\\n    char*: Serial_print_s, \\\n    signed long: Serial_print_i, \\\n    signed int: Serial_print_i, \\\n    signed char: Serial_print_c, \\\n    unsigned long: Serial_print_u, \\\n    unsigned int: Serial_print_u, \\\n    unsigned char: Serial_print_u \\\n    )(X)  This would unify some, but not all print function variants:     C++ name  C name using _Generic      Serial.print(int)  Serial_print    Serial.print(unsigned)  Serial_print    Serial.print(char)  Serial_print    Serial.print(char *)  Serial_print_s    Serial.print(char *buf, int len)  Serial_print_n    Serial.print(unsigned n, int base)  Serial_print_ub     Unfortunately cpp does not match string constants and  char*  resulting in a\nvery non-regular usage pattern:  char *string=\"Hello\";\n\nSerial_print(string);   // works\nSerial_print(\"Hello\");  // doesn't work\nSerial_print_s(\"Hello\");// works  To avoid too much confusion it might be better to not use  _Generic  at all.  Another problem using the  _Generic  selector is configurable instance\nnames. The preprocessor does not allow for variable macro names. That means _Generic  would work with fixed name like  Serial , but it wouldn't work\nfor  SoftwareSerial  with no standard instance name.",
            "title": "Polymorph functions"
        },
        {
            "location": "/api/migration/#inheritance-from-print-class",
            "text": "Most character output modules inherit methods from the Print class by\nproviding a virtual write method. A similar result can be achived by\nproviding a function pointer to the write function to be used to the print\nfunctions.  This additional parameter is hidden from the user by providing more\nconvinient defines in every library that need to 'inherit' functions from\nPrint. This way  lcd.print(\"Hello World!\")  becomes  lcd_print_s(\"Hello\nWorld!\")  and  Serial.print(\"Hello World!\")  becomes  Serial_print_s(\"Hello\nWorld!\") . Both call the same code from Print, but with different function\npointers to their own putchar/write function.",
            "title": "Inheritance from Print class"
        },
        {
            "location": "/api/migration/#libraries-with-multiple-instances",
            "text": "If multiple instances need to be supported, an approach similar to a C file\ndescriptor is used. The \"constructor\" function allocates and initializes a\ndata structure for one particular instance and return a pointer to this\nstructure. Typically, this is done in the  setup() -function and this pointer \nis stored in a global variable to be used as a device descriptor.  So far the  Stepper library  is the only example:  #include <Stepper.h>\nStepper myStepper;      // variable to store the \"device descriptor\"\nvoid setup(void) {\n    myStepper = Stepper_2phase(100,11,12);  // init a 2 phase stepper\n}\nvoid loop() {\n    Stepper_step(myStepper, 20);        // do 20 steps forward\n}",
            "title": "Libraries with multiple instances"
        },
        {
            "location": "/api/migration/#differences-from-the-original-arduino-environment",
            "text": "Additional output pin modes     Pin mode  Pin properties      OUTPUT  output, push-pull, slow mode (default)    OUTPUT_OD  output, open drain, fast mode    OUTPUT_FAST  output, push-pull, fast mode    OUTPUT_OD_FAST  output, open drain, fast mode     Timer  millis()  uses timer4. The prescaler and end value is calculated at compile\ntime for a cycle time as close to 1ms as possible. Default values @16Mhz:\nprescaler=64, counter cycle=250 (end value=249), resulting in exactly 1ms\nintervals.  timer1: PWM for PC3, PC4, on alternate mapping PC6, PC7, could be used for ADC \ntimer2: PWM for PA3, PD3, PD4 or PC5 (mutual exclusive) \ntimer4: millis()    Leaving out unused parts  Some functions of the core Arduino system can be left out on compilation to\nsave code space. This is done by compiler flags that can be defined in the\nMakefile:  BOARD_TAG = stm8sblue\nCFLAGS = -DNO_SERIAL -DNO_ANALOG_IN -DNO_ANALOG_OUT\n\ninclude ../../../sduino.mk  These flags are supported:     Flag  Bytes saved  Functions lost      NO_SERIAL  765  all serial communication    NO_ANALOG_OUT  406  analogWrite()    NO_ANALOG_IN  56  analogRead()     Other modifications  makeWord(unsigned char, unsigned char)  is an inline function now.  Additional compile-time flags  Some internal details can be influenced by setting compile-time defines\nusing the  CFLAGS=-Dflagname  line in the Makefile.  SUPPORT_ALTERNATE_MAPPINGS :\nAllow the use of  alternateFunctions()  ENABLE_SWIM :\nDo not disable the remote debugging function on the SWIM pin. This means\nthat this pin can not be used for normal I/O functions.  USE_SPL :\nUse SPL functions for I/O access instead of direct register accesses. Useful\nonly for debugging and porting to other CPU variants. Do not use for regular\ndevelopment.",
            "title": "Differences from the original Arduino environment"
        },
        {
            "location": "/api/migration/#general-notes-on-the-arduino-port",
            "text": "ADC  the prescaler is initialised for an ADC clock in the range of 1..2 MHz. The\nminimum prescaler value is 2, so for a clock speed of less than 2 MHz the\nrequired minimum ADC clock frequency can not be reached anymore.  Mapping of logical pin numbers to register addresses  The lookup-table approach for assigning port and bit adresses to the logical\npin numbers is not effient on the STM8. The hole system could be changed to\na more regular scheme and replace the tables by hardcoded adress\ncalculations.  Inefficient compilation  digitalWrite  compiles very ineffiently. It might be worth some hand\noptimization.  Accessing the alternate pin functions  Added  alternateFunction()  to allow switching of some pins to their alternate\nfunctions. This allows for three more PWM pins, but maybe it adds to much\ncomplexity for the Arduino API. Not sure if it should stay. Has to be\nenabled by defining  SUPPORT_ALTERNATE_MAPPINGS .  Useful CPU features that are not supported by the Arduino API  Input-Capture-Mode:  Available for all four channels, at least for\ntimer1. Would be great for precise time measurements. Maybe build a library?  Encoder interface mode:  Hardware support for reading quadrature encoder\nand keeping track of the current (motor) position using a hardware timer\ncounter. Perfectly suited to all kinds of position feedback.",
            "title": "General notes on the Arduino port"
        },
        {
            "location": "/api/Print/",
            "text": "Print\n\n\nFormatting functions for use with other output libraries. Involves serious\npreprocessor magic. See the \nmigration guidelines\n and\nthe \nxmacro description\n\n\nThis page is only a stub.\n\n\nAPI\n\n\nExample\n\n\nImplementation details\n\n\nPossible impovements",
            "title": "Print"
        },
        {
            "location": "/api/Print/#print",
            "text": "Formatting functions for use with other output libraries. Involves serious\npreprocessor magic. See the  migration guidelines  and\nthe  xmacro description  This page is only a stub.",
            "title": "Print"
        },
        {
            "location": "/api/Print/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/api/Print/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/api/Print/#implementation-details",
            "text": "",
            "title": "Implementation details"
        },
        {
            "location": "/api/Print/#possible-impovements",
            "text": "",
            "title": "Possible impovements"
        },
        {
            "location": "/api/HardwareSerial/",
            "text": "HardwareSerial\n\n\nUses the UART. API similar to Arduino. Single instance only.\nPre-instanciated.\n\n\nThis page is only a stub.\n\n\nAPI\n\n\nExample\n\n\nImplementation details\n\n\nPossible impovements",
            "title": "HardwareSerial"
        },
        {
            "location": "/api/HardwareSerial/#hardwareserial",
            "text": "Uses the UART. API similar to Arduino. Single instance only.\nPre-instanciated.  This page is only a stub.",
            "title": "HardwareSerial"
        },
        {
            "location": "/api/HardwareSerial/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/api/HardwareSerial/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/api/HardwareSerial/#implementation-details",
            "text": "",
            "title": "Implementation details"
        },
        {
            "location": "/api/HardwareSerial/#possible-impovements",
            "text": "",
            "title": "Possible impovements"
        },
        {
            "location": "/api/SPI/",
            "text": "SPI\n\n\nReal hardware-SPI up to 10MHz. No interrupt support yet.\n\n\nThis page is only a stub.\n\n\nAPI\n\n\nExample\n\n\nImplementation details\n\n\nPossible impovements",
            "title": "SPI"
        },
        {
            "location": "/api/SPI/#spi",
            "text": "Real hardware-SPI up to 10MHz. No interrupt support yet.  This page is only a stub.",
            "title": "SPI"
        },
        {
            "location": "/api/SPI/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/api/SPI/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/api/SPI/#implementation-details",
            "text": "",
            "title": "Implementation details"
        },
        {
            "location": "/api/SPI/#possible-impovements",
            "text": "",
            "title": "Possible impovements"
        },
        {
            "location": "/api/I2C/",
            "text": "I2C\n\n\nThe\n\nI2C master library\n\nby Wayne Truchsess offers some significant advantages over the Wire/TWI\nlibrary included in the standard arduino environment: It fixes some possible\ndeadlock situations, it allows for communication using a repeated start\ncondition as required by some devices, the code is much more compact and the\nstructure is easier to understand.\n\n\nThe current state of the port does not include the deadlock protection,\nthough.",
            "title": "I2C"
        },
        {
            "location": "/api/I2C/#i2c",
            "text": "The I2C master library \nby Wayne Truchsess offers some significant advantages over the Wire/TWI\nlibrary included in the standard arduino environment: It fixes some possible\ndeadlock situations, it allows for communication using a repeated start\ncondition as required by some devices, the code is much more compact and the\nstructure is easier to understand.  The current state of the port does not include the deadlock protection,\nthough.",
            "title": "I2C"
        },
        {
            "location": "/api/LiquidCrystal/",
            "text": "LiquidCrystal Library\n\n\nThis library is for character LCDs based on the HD44780 controller.\nDerived from the Arduino LiquidCrystal library v1.8.0.\n\n\nAPI\n\n\nThis library is a singleton library, it is not possible to use more than one\ninstance per sketch.\n\n\nThe API syntax is very similar to the original C++ syntax, thanks to some\n\nc preprocessor macro magic\n.\n\n\nApart from the usual name mangeling for polymorph functions (mostly the\ndifferent variants of the Print::print method) moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores is all it needs.\n\n\n\n\n\n\n\n\nArduino syntax\n\n\nsduino syntax\n\n\n\n\n\n\n\n\n\n\nLiquidCrystal lcd(rs,en,d0,d1,d2,d3)\n\n\nLiquidCrystal (lcd,rs,en,d0,d1,d2,d3)\n\n\n\n\n\n\nLiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3)\n\n\nLiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3)\n\n\n\n\n\n\nLiquidCrystal lcd(rs,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\nLiquidCrystal (lcd,rs,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\n\n\n\n\nLiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\nLiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\n\n\n\n\nlcd.init(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\nlcd_init(mode,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)\n\n\n\n\n\n\nlcd.begin(cols,lines)\n\n\nlcd_begin(cols,lines)\n\n\n\n\n\n\nlcd.begin(cols,lines,charsize)\n\n\nlcd_begin_charsize(cols,lines,charsize)\n\n\n\n\n\n\nlcd.clear()\n\n\nlcd_clear()\n\n\n\n\n\n\nlcd.home()\n\n\nlcd_home()\n\n\n\n\n\n\nlcd.noDisplay()\n\n\nlcd_noDisplay()\n\n\n\n\n\n\nlcd.display()\n\n\nlcd_display()\n\n\n\n\n\n\nlcd.noBlink()\n\n\nlcd_noBlink()\n\n\n\n\n\n\nlcd.blink()\n\n\nlcd_blink()\n\n\n\n\n\n\nlcd.noCursor()\n\n\nlcd_noCursor()\n\n\n\n\n\n\nlcd.cursor()\n\n\nlcd_cursor()\n\n\n\n\n\n\nlcd.scrollDisplayLeft()\n\n\nlcd_scrollDisplayLeft()\n\n\n\n\n\n\nlcd.scrollDisplayRight()\n\n\nlcd_scrollDisplayRight()\n\n\n\n\n\n\nlcd.leftToRight()\n\n\nlcd_leftToRight()\n\n\n\n\n\n\nlcd.rightToLeft()\n\n\nlcd_rightToLeft()\n\n\n\n\n\n\nlcd.noAutoscroll()\n\n\nlcd_noAutoscroll()\n\n\n\n\n\n\nlcd.autoscroll()\n\n\nlcd_autoscroll()\n\n\n\n\n\n\nlcd.setRowOffsets(row0,row1,row2,row3)\n\n\nlcd_setRowOffsets(row0,row1,row2,row3)\n\n\n\n\n\n\nlcd.createChar(number, data[])\n\n\nlcd_createChar(number, data[])\n\n\n\n\n\n\nlcd.setCursor(col,row)\n\n\nlcd_setCursor(col,row)\n\n\n\n\n\n\nresult = lcd.write(value)\n\n\nresult = lcd_write(value)\n\n\n\n\n\n\nlcd.command(value)\n\n\nlcd_command(value)\n\n\n\n\n\n\n\n\nThe LCD interface mode can be changed at run time by calling the\n\nlcd_init(...)\n function.\n\n\nExample\n\n\nOutput some Text and count the time since the last reset. Notice the\nslightly different position of the opening parenthesis at the \"class\nconstructor\" function LiquidCrystal compared to the C++ instatiation.\n\n\n#include <Arduino.h>\n#include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *within* the brackets\nLiquidCrystal (lcd,PA1,PA2, PA3,PD2,PD3,PD4);\n\nvoid setup() {\n  lcd_begin(16, 2);\n  lcd_print_s(\"hello, world!\");\n}\n\n\nvoid loop() {\n  lcd_setCursor(0, 1);\n  lcd_print_u(millis() / 1000);\n}\n\n\n\n\nCompare it to the original Arduino C++-Sytax:\n\n\n#include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *before* the brackets\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n  lcd.begin(16, 2);\n  lcd.print(\"hello, world!\");\n}\n\nvoid loop() {\n  lcd.setCursor(0, 1);\n  lcd.print(millis() / 1000);\n}\n\n\n\n\nPossible improvements\n\n\nThis is not a to-do-list, just brainstorming and a collection of random\nthoughts.\n\n\nDirect port access\n\n\nAs long as the pin numberings are known at compile time it would be possible\nuse direct port register access and the access pattern could be optimized if\nall data pins are on the same port.\n\n\nAuto-detect 4-bit mode\n\n\nThe parameter \nfourbitmode\n of the init() function/method is not needed. It\nwould be sufficient to check \nd5\n for a valid value. If it is not valid,\nassume 4-bit mode.\n\n\nAs init() is not called very frequently the possible advantage would be small\ncompared to the downside of breaking the Arduino compatibility.",
            "title": "LiquidCrystal character LCD library"
        },
        {
            "location": "/api/LiquidCrystal/#liquidcrystal-library",
            "text": "This library is for character LCDs based on the HD44780 controller.\nDerived from the Arduino LiquidCrystal library v1.8.0.",
            "title": "LiquidCrystal Library"
        },
        {
            "location": "/api/LiquidCrystal/#api",
            "text": "This library is a singleton library, it is not possible to use more than one\ninstance per sketch.  The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic .  Apart from the usual name mangeling for polymorph functions (mostly the\ndifferent variants of the Print::print method) moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores is all it needs.     Arduino syntax  sduino syntax      LiquidCrystal lcd(rs,en,d0,d1,d2,d3)  LiquidCrystal (lcd,rs,en,d0,d1,d2,d3)    LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3)  LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3)    LiquidCrystal lcd(rs,en,d0,d1,d2,d3,d4,d5,d6,d7)  LiquidCrystal (lcd,rs,en,d0,d1,d2,d3,d4,d5,d6,d7)    LiquidCrystal lcd(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)  LiquidCrystal (lcd,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)    lcd.init(rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)  lcd_init(mode,rs,rw,en,d0,d1,d2,d3,d4,d5,d6,d7)    lcd.begin(cols,lines)  lcd_begin(cols,lines)    lcd.begin(cols,lines,charsize)  lcd_begin_charsize(cols,lines,charsize)    lcd.clear()  lcd_clear()    lcd.home()  lcd_home()    lcd.noDisplay()  lcd_noDisplay()    lcd.display()  lcd_display()    lcd.noBlink()  lcd_noBlink()    lcd.blink()  lcd_blink()    lcd.noCursor()  lcd_noCursor()    lcd.cursor()  lcd_cursor()    lcd.scrollDisplayLeft()  lcd_scrollDisplayLeft()    lcd.scrollDisplayRight()  lcd_scrollDisplayRight()    lcd.leftToRight()  lcd_leftToRight()    lcd.rightToLeft()  lcd_rightToLeft()    lcd.noAutoscroll()  lcd_noAutoscroll()    lcd.autoscroll()  lcd_autoscroll()    lcd.setRowOffsets(row0,row1,row2,row3)  lcd_setRowOffsets(row0,row1,row2,row3)    lcd.createChar(number, data[])  lcd_createChar(number, data[])    lcd.setCursor(col,row)  lcd_setCursor(col,row)    result = lcd.write(value)  result = lcd_write(value)    lcd.command(value)  lcd_command(value)     The LCD interface mode can be changed at run time by calling the lcd_init(...)  function.",
            "title": "API"
        },
        {
            "location": "/api/LiquidCrystal/#example",
            "text": "Output some Text and count the time since the last reset. Notice the\nslightly different position of the opening parenthesis at the \"class\nconstructor\" function LiquidCrystal compared to the C++ instatiation.  #include <Arduino.h>\n#include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *within* the brackets\nLiquidCrystal (lcd,PA1,PA2, PA3,PD2,PD3,PD4);\n\nvoid setup() {\n  lcd_begin(16, 2);\n  lcd_print_s(\"hello, world!\");\n}\n\n\nvoid loop() {\n  lcd_setCursor(0, 1);\n  lcd_print_u(millis() / 1000);\n}  Compare it to the original Arduino C++-Sytax:  #include <LiquidCrystal.h>\n\n// initialize the library with the numbers of the interface pins\n// The instance name \"lcd\" is *before* the brackets\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n  lcd.begin(16, 2);\n  lcd.print(\"hello, world!\");\n}\n\nvoid loop() {\n  lcd.setCursor(0, 1);\n  lcd.print(millis() / 1000);\n}",
            "title": "Example"
        },
        {
            "location": "/api/LiquidCrystal/#possible-improvements",
            "text": "This is not a to-do-list, just brainstorming and a collection of random\nthoughts.  Direct port access  As long as the pin numberings are known at compile time it would be possible\nuse direct port register access and the access pattern could be optimized if\nall data pins are on the same port.  Auto-detect 4-bit mode  The parameter  fourbitmode  of the init() function/method is not needed. It\nwould be sufficient to check  d5  for a valid value. If it is not valid,\nassume 4-bit mode.  As init() is not called very frequently the possible advantage would be small\ncompared to the downside of breaking the Arduino compatibility.",
            "title": "Possible improvements"
        },
        {
            "location": "/api/PCD8544/",
            "text": "PCD8544 Library\n\n\nThis library is for monochrome graphical LCD based on the Philips PCD8544\ncontroller\n(\ndatasheet\n)\nor compatibles. These displays quite cheap and are commonly found on older monochrome mobile\nphones, such as the \nNokia 3310\n or\n\n5110\n.\n\n\nThis library is a very much simpified version of the Adafruit library.\n\n\n\n\nOptimized for a minimal memory footprint.\n\n\nOnly SPI mode supported. \n\n\nUses soft-SPI, does not need the SPI pins.\n\n\n\n\nThis is a modified version of the\n\nPCD8544 library\n written by\n\nCarlos Rodrigues\n. It is ported from C++ to C\nsyntax and is meant to be used with the sduino environment for the STM8.\n\n\nThis library is meant to have a minimal memory footprint. If you need\ngraphics and other features and can spare the resources, check out the\n\nlibrary\n\nfrom Adafruit (no sduino/STM8 port yet, though).\n\n\nAPI\n\n\nThanks to some \nc preprocessor macro magic\n the API syntax is\nvery similar to the original C++ syntax. Apart from the usual name mangeling\nfor polymorph functions replacing the dots in the method names for\nunderscores and a small modification of the initializer code should be\nenough. See below for an example.\n\n\nThe instantiation \"method\" can be called only one time per sketch as this\nlibrary is a singleton library. It is not possible to use more than one\ninstance per sketch.\n\n\n\n\n\n\n\n\nArduino syntax\n\n\nsduino syntax\n\n\n\n\n\n\n\n\n\n\nPCD8544 lcd\n\n\nno default pin mapping supported\n\n\n\n\n\n\nPCD8544 lcd(sclk,sdin,dc,reset,sce)\n\n\nPCD8544 (lcd,sclk,sdin,dc,reset,sce)\n\n\n\n\n\n\nlcd.begin()\n\n\nlcd_begin()\n\n\n\n\n\n\nlcd.begin(width,height)\n\n\nlcd_begin_wh(width,height)\n\n\n\n\n\n\nlcd.begin(width,height,chiptype)\n\n\nlcd_begin_full(width,height,chiptype)\n\n\n\n\n\n\nlcd.stop()\n\n\nlcd_stop()\n\n\n\n\n\n\nlcd.clear()\n\n\nlcd_clear()\n\n\n\n\n\n\nlcd.clearLine()\n\n\nlcd_clearLine()\n\n\n\n\n\n\nlcd.setPower(flag)\n\n\nlcd_setPower(flag)\n\n\n\n\n\n\nlcd.display()\n\n\nlcd_display()\n\n\n\n\n\n\nlcd.noDisplay()\n\n\nlcd_noDisplay()\n\n\n\n\n\n\nlcd.setInverse(flag)\n\n\nlcd_setInverse(flag)\n\n\n\n\n\n\nlcd.setContrast(level)\n\n\nlcd_setContrast(level)\n\n\n\n\n\n\nlcd.home()\n\n\nlcd_home()\n\n\n\n\n\n\nlcd.setCursor(col,line)\n\n\nlcd_setCursor(col,line)\n\n\n\n\n\n\nresult = lcd.write(value)\n\n\nresult = lcd_write(value)\n\n\n\n\n\n\nlcd.createChar(chr,glyph[])\n\n\nlcd_createChar(chr,glyph)\n\n\n\n\n\n\nlcd.drawBitmap(data[],columns,lines)\n\n\nlcd_drawBitmap(data[],columns,lines)\n\n\n\n\n\n\nlcd.drawColumn(lines, value)\n\n\nlcd.drawColumn(lines, value)\n\n\n\n\n\n\n\n\nThe default resolution of 84x48 fits the commons Nokia 5110 display.\n\n\nExample\n\n\n#include <PCD8544.h>\n\nPCD8544(lcd, PC5, PC6, PC4, PC7, PD1); // sclk,sdin,dc,reset,sce\n\nint counter = 0;\n\nvoid setup() {\n  lcd_begin();  // default resolution is 84x48\n}\n\n\nvoid loop() {\n  // Write some text on the first line...\n  lcd_setCursor(0, 0);\n  lcd_print_s(\"Hello, World!\");\n\n  // Write the counter on the second line...\n  lcd_setCursor(0, 1);\n  lcd_print_u(counter);\n\n  delay(200);\n  counter++;\n}\n\n\n\n\nHardware connections\n\n\nTo use this library, you must first connect your LCD to the proper pins on\nthe STM8 board. This library uses bitbanging for the SPI data transfer, so\nyou are not bound to the SPI pins for SCLK and MOSI.\n\n\nFor a Nokia 5510 display connected to a STM8S103 breakout board, the\nconnections look like this:\n\n\n\n\n\n\n\n\nDisplay Pin\n\n\nSTM8S breakout board\n\n\n\n\n\n\n\n\n\n\nPin 1 (VCC)\n\n\n+3.3V (marked by a square around the pin on the silkscreen)\n\n\n\n\n\n\nPin 2 (GND)\n\n\nGround\n\n\n\n\n\n\nPin 3 (SCE)\n\n\nSTM8S103 pin PD1 (sduino digital pin 10)\n\n\n\n\n\n\nPin 4 (RST)\n\n\nSTM8S103 pin PC7 (sduino digital pin 9)\n\n\n\n\n\n\nPin 5 (D/C)\n\n\nSTM8S103 pin PC4 (sduino digital pin 6)\n\n\n\n\n\n\nPin 6 (MOSI)\n\n\nSTM8S103 pin PC6 (sduino digital pin 8)\n\n\n\n\n\n\nPin 7 (SCLK)\n\n\nSTM8S103 pin PC5 (sduino digital pin 7)\n\n\n\n\n\n\nPin 8 (LED)\n\n\n82 Ohm resistor to 3.3V or 330 Ohm to 5V\n\n\n\n\n\n\n\n\nSince the STM8S works on 3.3V you can connect the data lines directly to\nport lines. If you are using this display with a 5V CPU (like on most\nArduino boards), you have to add extra components to connect it to the\ndigital pins of the Arduino (not necessary if you are using a 3.3V\nvariant of the Arduino, such as Sparkfun's Arduino Pro).\n\n\nThe background LEDs need only 2.8V/6mA. If you connect them to a port pin,\nprefer a HS (High sink) pin (see CPU datasheet, all pins except the\noscillator and the I2C pin PA1/PA2 and PB4/PB5). PWM pins are the best\nchoice.\n\n\nwhen soldering the pin connectors, keep in mind that the upside of the\ndisplay is the thicker part of the metal frame.\n\n\nFor a Nokia 3310 display the connections would be the following:\n\n\n\n\n\n\n\n\nDisplay Pin\n\n\nArduino Pin\n\n\n\n\n\n\n\n\n\n\nPin 1\n\n\n+3.3V Pin\n\n\n\n\n\n\nPin 2 (SCLK)\n\n\nPC5, digital Pin 7\n\n\n\n\n\n\nPin 3 (SDIN/MOSI)\n\n\nPC6, digital Pin 8\n\n\n\n\n\n\nPin 4 (D/C)\n\n\nPC4, digital Pin 6\n\n\n\n\n\n\nPin 5 (SCE)\n\n\nPD1, digital Pin 10\n\n\n\n\n\n\nPin 6\n\n\nGround Pin\n\n\n\n\n\n\nPin 7\n\n\n10uF capacitor to Ground Pin\n\n\n\n\n\n\nPin 8 (RST)\n\n\nPC7, digital Pin 9\n\n\n\n\n\n\n\n\nFor this display model, \"Pin 1\" is the leftmost pin when facing the back of\nthe display with the connector on top.\n\n\nCustom Symbols\n\n\nThe library allows the use of custom bitmap symbols (5x8), defined by an\narray of five bytes. Checkout the examples in the library folder for usage\nof this function.\n\n\nTo make it easy to create custom symbols, there's a\ngraphical glyph editor \navailable online\n.",
            "title": "PCD8544 libray for Nokia 5110-like graphical LCDs"
        },
        {
            "location": "/api/PCD8544/#pcd8544-library",
            "text": "This library is for monochrome graphical LCD based on the Philips PCD8544\ncontroller\n( datasheet )\nor compatibles. These displays quite cheap and are commonly found on older monochrome mobile\nphones, such as the  Nokia 3310  or 5110 .  This library is a very much simpified version of the Adafruit library.   Optimized for a minimal memory footprint.  Only SPI mode supported.   Uses soft-SPI, does not need the SPI pins.   This is a modified version of the PCD8544 library  written by Carlos Rodrigues . It is ported from C++ to C\nsyntax and is meant to be used with the sduino environment for the STM8.  This library is meant to have a minimal memory footprint. If you need\ngraphics and other features and can spare the resources, check out the library \nfrom Adafruit (no sduino/STM8 port yet, though).",
            "title": "PCD8544 Library"
        },
        {
            "location": "/api/PCD8544/#api",
            "text": "Thanks to some  c preprocessor macro magic  the API syntax is\nvery similar to the original C++ syntax. Apart from the usual name mangeling\nfor polymorph functions replacing the dots in the method names for\nunderscores and a small modification of the initializer code should be\nenough. See below for an example.  The instantiation \"method\" can be called only one time per sketch as this\nlibrary is a singleton library. It is not possible to use more than one\ninstance per sketch.     Arduino syntax  sduino syntax      PCD8544 lcd  no default pin mapping supported    PCD8544 lcd(sclk,sdin,dc,reset,sce)  PCD8544 (lcd,sclk,sdin,dc,reset,sce)    lcd.begin()  lcd_begin()    lcd.begin(width,height)  lcd_begin_wh(width,height)    lcd.begin(width,height,chiptype)  lcd_begin_full(width,height,chiptype)    lcd.stop()  lcd_stop()    lcd.clear()  lcd_clear()    lcd.clearLine()  lcd_clearLine()    lcd.setPower(flag)  lcd_setPower(flag)    lcd.display()  lcd_display()    lcd.noDisplay()  lcd_noDisplay()    lcd.setInverse(flag)  lcd_setInverse(flag)    lcd.setContrast(level)  lcd_setContrast(level)    lcd.home()  lcd_home()    lcd.setCursor(col,line)  lcd_setCursor(col,line)    result = lcd.write(value)  result = lcd_write(value)    lcd.createChar(chr,glyph[])  lcd_createChar(chr,glyph)    lcd.drawBitmap(data[],columns,lines)  lcd_drawBitmap(data[],columns,lines)    lcd.drawColumn(lines, value)  lcd.drawColumn(lines, value)     The default resolution of 84x48 fits the commons Nokia 5110 display.",
            "title": "API"
        },
        {
            "location": "/api/PCD8544/#example",
            "text": "#include <PCD8544.h>\n\nPCD8544(lcd, PC5, PC6, PC4, PC7, PD1); // sclk,sdin,dc,reset,sce\n\nint counter = 0;\n\nvoid setup() {\n  lcd_begin();  // default resolution is 84x48\n}\n\n\nvoid loop() {\n  // Write some text on the first line...\n  lcd_setCursor(0, 0);\n  lcd_print_s(\"Hello, World!\");\n\n  // Write the counter on the second line...\n  lcd_setCursor(0, 1);\n  lcd_print_u(counter);\n\n  delay(200);\n  counter++;\n}",
            "title": "Example"
        },
        {
            "location": "/api/PCD8544/#hardware-connections",
            "text": "To use this library, you must first connect your LCD to the proper pins on\nthe STM8 board. This library uses bitbanging for the SPI data transfer, so\nyou are not bound to the SPI pins for SCLK and MOSI.  For a Nokia 5510 display connected to a STM8S103 breakout board, the\nconnections look like this:     Display Pin  STM8S breakout board      Pin 1 (VCC)  +3.3V (marked by a square around the pin on the silkscreen)    Pin 2 (GND)  Ground    Pin 3 (SCE)  STM8S103 pin PD1 (sduino digital pin 10)    Pin 4 (RST)  STM8S103 pin PC7 (sduino digital pin 9)    Pin 5 (D/C)  STM8S103 pin PC4 (sduino digital pin 6)    Pin 6 (MOSI)  STM8S103 pin PC6 (sduino digital pin 8)    Pin 7 (SCLK)  STM8S103 pin PC5 (sduino digital pin 7)    Pin 8 (LED)  82 Ohm resistor to 3.3V or 330 Ohm to 5V     Since the STM8S works on 3.3V you can connect the data lines directly to\nport lines. If you are using this display with a 5V CPU (like on most\nArduino boards), you have to add extra components to connect it to the\ndigital pins of the Arduino (not necessary if you are using a 3.3V\nvariant of the Arduino, such as Sparkfun's Arduino Pro).  The background LEDs need only 2.8V/6mA. If you connect them to a port pin,\nprefer a HS (High sink) pin (see CPU datasheet, all pins except the\noscillator and the I2C pin PA1/PA2 and PB4/PB5). PWM pins are the best\nchoice.  when soldering the pin connectors, keep in mind that the upside of the\ndisplay is the thicker part of the metal frame.  For a Nokia 3310 display the connections would be the following:     Display Pin  Arduino Pin      Pin 1  +3.3V Pin    Pin 2 (SCLK)  PC5, digital Pin 7    Pin 3 (SDIN/MOSI)  PC6, digital Pin 8    Pin 4 (D/C)  PC4, digital Pin 6    Pin 5 (SCE)  PD1, digital Pin 10    Pin 6  Ground Pin    Pin 7  10uF capacitor to Ground Pin    Pin 8 (RST)  PC7, digital Pin 9     For this display model, \"Pin 1\" is the leftmost pin when facing the back of\nthe display with the connector on top.",
            "title": "Hardware connections"
        },
        {
            "location": "/api/PCD8544/#custom-symbols",
            "text": "The library allows the use of custom bitmap symbols (5x8), defined by an\narray of five bytes. Checkout the examples in the library folder for usage\nof this function.  To make it easy to create custom symbols, there's a\ngraphical glyph editor  available online .",
            "title": "Custom Symbols"
        },
        {
            "location": "/api/Mini_SSD1306/",
            "text": "Mini_SSD1306\n\n\nThis is a library for monochrome OLEDs based on SSD1306 drivers.\n\n\nThis library is a stripped-down version of the original\n\nAdafruit_SSD1306 library\n\nv1.1.2.\nThis version of the library does not depend on the Adafruit_GFX library and\nhas a \nmuch\n smaller memory footprint than the full version, but most of the\ngraphical features are missing.\n\n\nThe Library only supports I2C communication.\n\n\nAPI\n\n\nSSD1306(instancename, pin_reset);\n\nvoid Mini_SSD1306_begin(uint8_t switchvcc, uint8_t i2caddr, bool reset);\nvoid Mini_SSD1306_clearDisplay(void);\nvoid Mini_SSD1306_invertDisplay(uint8_t i);\nvoid Mini_SSD1306_display();\nvoid Mini_SSD1306_startscrollright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrollleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_stopscroll(void);\nvoid Mini_SSD1306_dim(boolean dim);\nvoid Mini_SSD1306_drawPixel(int16_t x, int16_t y, uint8_t color);\n\n\n\n\nExample\n\n\nThe library initializes the display buffer with the Adafruit splash screen.\nSince it is not modified, \noled_display()\n shows it. The loop draws a\npattern of blinking pixels in an 8x8 grid:\n\n\n#include \"I2C.h\"\n#include \"Mini_SSD1306.h\"\n\nMini_SSD1306(oled,-1);  // -1 means no reset pin\n\n#if (SSD1306_LCDHEIGHT != 64)\n#error(\"Height incorrect, please fix Mini_SSD1306.h!\");\n#endif\n\nvoid setup()\n{\n    // Initialize with the I2C addr 0x3C. Some displays use 0x3D instead.\n    oled_begin(SSD1306_SWITCHCAPVCC, 0x3C,0);\n}\n\nvoid loop()\n{\n    uint8_t x,y;\n\n    oled_display(); // show the display buffer\n    delay (1000);\n\n    // draw some dots in an 8x8 pattern\n    for (x=0; x<WIDTH; x+=8)\n    {\n        for (y=0; y<HEIGHT-8; y+=8) // don't alter the stack!\n        {\n            oled_drawPixel(x,y,INVERSE);\n        }\n    }\n}\n\n\n\n\nHardware requirements\n\n\nThese tiny displays communicate usually via I2C, but SPI versions do exist.\nMy display uses the I2C address 0x3C, but there are similar displays out\nthere configured to use the address 0x3D.\n\n\nThe display content has to be kept in memory as it is not possible to read\nthe memory content of the physical display. For 128x64 pixel this requires\n1kB of RAM. For low-memory devices like the STM8S103 it means the display\nbuffer overlaps with the stack. Notice the chaotic pattern in the lower part\nof the screen:\n\n\n\n\nTechnical data:\n\n\n\n\nDriver chip SSD1306\n\n\nDisplay resolution: 128x64\n\n\nPower: 3.3V, approx. 20mA (5V possible)\n\n\nInterface: I2C, some modules support SPI as well\n\n\nI2C-Address: 0x3c, configurable to 0x3d by setting a solder bridge (on\n    some modules)\n\n\n\n\nPin out of an I2C module:\n\n\n\n\n\n\n\n\nPin\n\n\nFunction\n\n\nSTM8S103 pin\n\n\nsduino pin\n\n\n\n\n\n\n\n\n\n\n1\n\n\nGND\n\n\n\n\n\n\n\n\n\n\n2\n\n\nVcc\n\n\n\n\n\n\n\n\n\n\n3\n\n\nSCL\n\n\nPB4\n\n\nPIN_WIRE_SCL, SCL, 4\n\n\n\n\n\n\n4\n\n\nSDA\n\n\nPB5\n\n\nPIN_WIRE_SDA, SDA, 3\n\n\n\n\n\n\n\n\nFurther reading\n\n\nTechnical information:\n\n\n\n\nAdafruit tutorial\n\n\nSSD1306 datasheet\n\n\n\n\nOther libraries:\n\n\n\n\nAdafruit library\n\n\nOld Arduino library u8glib\n\n\nnewer library u8g2\n\n\n\n\nPossible improvements\n\n\nFaster I2C transfer\n\n\nFaster I2C transfer is supported by the \nI2C library\n, but to use\nit you have to modify the source code for the Mini_SSD1306 library. Make\nthis configurable in the instantiation function.",
            "title": "Mini_SSD1306 library for monochrome OLED-displays"
        },
        {
            "location": "/api/Mini_SSD1306/#mini_ssd1306",
            "text": "This is a library for monochrome OLEDs based on SSD1306 drivers.  This library is a stripped-down version of the original Adafruit_SSD1306 library \nv1.1.2.\nThis version of the library does not depend on the Adafruit_GFX library and\nhas a  much  smaller memory footprint than the full version, but most of the\ngraphical features are missing.  The Library only supports I2C communication.",
            "title": "Mini_SSD1306"
        },
        {
            "location": "/api/Mini_SSD1306/#api",
            "text": "SSD1306(instancename, pin_reset);\n\nvoid Mini_SSD1306_begin(uint8_t switchvcc, uint8_t i2caddr, bool reset);\nvoid Mini_SSD1306_clearDisplay(void);\nvoid Mini_SSD1306_invertDisplay(uint8_t i);\nvoid Mini_SSD1306_display();\nvoid Mini_SSD1306_startscrollright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrollleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagright(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_startscrolldiagleft(uint8_t start, uint8_t stop);\nvoid Mini_SSD1306_stopscroll(void);\nvoid Mini_SSD1306_dim(boolean dim);\nvoid Mini_SSD1306_drawPixel(int16_t x, int16_t y, uint8_t color);",
            "title": "API"
        },
        {
            "location": "/api/Mini_SSD1306/#example",
            "text": "The library initializes the display buffer with the Adafruit splash screen.\nSince it is not modified,  oled_display()  shows it. The loop draws a\npattern of blinking pixels in an 8x8 grid:  #include \"I2C.h\"\n#include \"Mini_SSD1306.h\"\n\nMini_SSD1306(oled,-1);  // -1 means no reset pin\n\n#if (SSD1306_LCDHEIGHT != 64)\n#error(\"Height incorrect, please fix Mini_SSD1306.h!\");\n#endif\n\nvoid setup()\n{\n    // Initialize with the I2C addr 0x3C. Some displays use 0x3D instead.\n    oled_begin(SSD1306_SWITCHCAPVCC, 0x3C,0);\n}\n\nvoid loop()\n{\n    uint8_t x,y;\n\n    oled_display(); // show the display buffer\n    delay (1000);\n\n    // draw some dots in an 8x8 pattern\n    for (x=0; x<WIDTH; x+=8)\n    {\n        for (y=0; y<HEIGHT-8; y+=8) // don't alter the stack!\n        {\n            oled_drawPixel(x,y,INVERSE);\n        }\n    }\n}",
            "title": "Example"
        },
        {
            "location": "/api/Mini_SSD1306/#hardware-requirements",
            "text": "These tiny displays communicate usually via I2C, but SPI versions do exist.\nMy display uses the I2C address 0x3C, but there are similar displays out\nthere configured to use the address 0x3D.  The display content has to be kept in memory as it is not possible to read\nthe memory content of the physical display. For 128x64 pixel this requires\n1kB of RAM. For low-memory devices like the STM8S103 it means the display\nbuffer overlaps with the stack. Notice the chaotic pattern in the lower part\nof the screen:   Technical data:   Driver chip SSD1306  Display resolution: 128x64  Power: 3.3V, approx. 20mA (5V possible)  Interface: I2C, some modules support SPI as well  I2C-Address: 0x3c, configurable to 0x3d by setting a solder bridge (on\n    some modules)   Pin out of an I2C module:     Pin  Function  STM8S103 pin  sduino pin      1  GND      2  Vcc      3  SCL  PB4  PIN_WIRE_SCL, SCL, 4    4  SDA  PB5  PIN_WIRE_SDA, SDA, 3",
            "title": "Hardware requirements"
        },
        {
            "location": "/api/Mini_SSD1306/#further-reading",
            "text": "Technical information:   Adafruit tutorial  SSD1306 datasheet   Other libraries:   Adafruit library  Old Arduino library u8glib  newer library u8g2",
            "title": "Further reading"
        },
        {
            "location": "/api/Mini_SSD1306/#possible-improvements",
            "text": "Faster I2C transfer  Faster I2C transfer is supported by the  I2C library , but to use\nit you have to modify the source code for the Mini_SSD1306 library. Make\nthis configurable in the instantiation function.",
            "title": "Possible improvements"
        },
        {
            "location": "/api/Stepper/",
            "text": "Stepper Library\n\n\nA Library for driving stepper motors with 2, 4 or 5 phases.\nDerived from the Arduino Stepper library v1.8.0.\n\n\nAPI\n\n\nThis library is a multi-instance library, it supports an arbitrary number of\nstepper motors per sketch.\n\n\nThe API syntax is very similar to the original C++ syntax, thanks to some\n\nc preprocessor macro magic\n.\n\n\nThe declaration supports polymorphism, so all that is needed to adopt an\nexisting sketch for use with sduino is moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores.\n\n\n\n\n\n\n\n\nArduino method\n\n\nsduino function\n\n\n\n\n\n\n\n\n\n\nStepper myStepper(steps, pin1,pin2);\n\n\nStepper (myStepper,steps,pin1,pin2);\n\n\n\n\n\n\nStepper myStepper(steps, pin1,pin2,pin3,pin4);\n\n\nStepper (myStepper,steps,pin1,pin2,pin3,pin4);\n\n\n\n\n\n\nStepper myStepper(steps, pin1,pin2,pin3,pin4,pin5);\n\n\nStepper (myStepper,steps,pin1,pin2,pin3,pin4,pin5);\n\n\n\n\n\n\nmyStepper.setSpeed(speed);\n\n\nmyStepper_setSpeed(speed);\n\n\n\n\n\n\nmyStepper.step(n);\n\n\nmyStepper_step(n);\n\n\n\n\n\n\nmyStepper.version();\n\n\nmyStepper_version();\n\n\n\n\n\n\n\n\nAPI additions\n\n\nThe sduino implementation adds some extra methods to the stock Stepper\nlibrary to allow to work arounds some limitations of C code vs. C++:\n\n\n\n\n\n\n\n\nArduino method\n\n\nsduino function\n\n\n\n\n\n\n\n\n\n\ndone automatically on start up\n\n\nmyStepper_activateOutputs();\n\n\n\n\n\n\nnot impemented\n\n\nmyStepper_2phase(steps,pin1,pin2);\n\n\n\n\n\n\nnot impemented\n\n\nmyStepper_4phase(steps,pin1,pin2,pin3,pin4);\n\n\n\n\n\n\nnot impemented\n\n\nmyStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5);\n\n\n\n\n\n\n\n\nInitializing the output pins on demand\n\n\nIn real C++ the internal class constructor method initializes the motor pins\nto output mode automatically at start up of the programm. In C this doesn't\nhappen automatically. Most libraries implement a begin() method for exactly\nthis purpose, but this one does not include an explicit constructor method.\n\n\nInstead, the output mode is set automatically right before the very first\nmotor step. This means that the driver pins stay uninitialized and are left\nfloating from the time of power up until the first step is requested. This\nwon't be a problem in most cases as most motor drivers are using pull-up or\npull-down resistors to ensure proper signal levels.\n\n\nIf needed, the application could call the added \nactivateOutputs()\n method\nin the setup() function to force an immediate port pin initialization:\n\n\nsetup() {\n  myStepper_activateOutputs();    // initializes the motor pins to output mode\n}\n\n\n\n\nAssigning the pin connections at run time\n\n\nThe way the instantiation macro works requires compile-time constant values\nfor all parameters (see below in section 'Implementation Details'). In order\nto be able to (re-) configure the pin connections at run time this version\nof the library implements the functions \n2phase()\n, \n4phase()\n and\n\n5phase()\n. These functions act like a constructor and allow for full\nre-initialisation of an already existing \"object\".\n\n\nIf you need to (re-) configure the pin connections at run time (e.g. read it\nfrom a configuration EEPROM first) you can initialize a data structure with\n\n0\n for the unknown pin numbers and set them later by calling the right\nxphase()-function:\n\n\nStepper (myStepper,0,0);\n\nsetup() {\n    ... figure out the pin numbers somehow ...\n    myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4);\n    ...\n}\n\nloop () {\n    ...\n    myStepper_setSpeed(60);\n    myStepper_step(100);\n    ...\n}\n\n\n\n\n\n5 phase support can be deactivated to save code space\n\n\n5 phase motors are not very common, but supporting them increases the code\nsize significantly. By defining the compiler flag NO_5PHASE it is possible\nto deactivate the support for 5 phase motors. This saves 736 bytes of code\nspace. Add this line to your Makefile if you don't need 5 phase support:\n\n\nCFLAGS = -DNO_5PHASE\n\n\n\n\nExample\n\n\nNotice the slightly different position of the opening parenthesis at the\n\"class constructor\" 'function' Stepper compared to the C++ instantiation.\n(available in the examples folder as \nstepper_oneRevolution.c\n)\n\n\nC-Version for use with sduino:\n\n\n#include <Arduino.h>\n#include <Stepper.h>\n\n// change this to fit the number of steps per revolution for your motor\n#define stepsPerRevolution 200\n\n// initialize the stepper library on pins 8 through 11:\nStepper (myStepper,stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper_setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper_step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper_step(-stepsPerRevolution);\n  delay(500);\n}\n\n\n\n\nOriginal Arduino C++-Sytax:\n\n\n#include <Stepper.h>\n\nconst int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution\n// for your motor\n\n// initialize the stepper library on pins 8 through 11:\nStepper myStepper(stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper.setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper.step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper.step(-stepsPerRevolution);\n  delay(500);\n}\n\n\n\n\nImplementation details\n\n\nTechnically, each Stepper instance is represented by a file-descriptor-like\nstructure. This structure is initialized by the instantiation macro\n\nStepper\n. This means that all values are required to be constant values,\nknown at compile time. A \nconst\n qualifier is not enough for SDCC, it\nrequires either a \n#define\n or an \nenum\n:\n\n\nconst int numOfSteps = 1;   // does not work with SDCC\n#define MotorPin1  10       // ok, works\nenum { MotorPin2 = 11 };    // ok, works\n\nStepper (myStepper, numOfSteps, MotorPin1, MotorPin2);\n\n\n\n\nAll functions require a pointer to the stepper data structur as their first\nargument to identify the stepper instance. All this pointer handling is\nhidden by preprocessor magic, but it is still real and pure C. If you\ninsist, you can still call the 'real' functions yourself (but you gain\nnothing, the compiler produces exactly the same output).\n\n\nPossible impovements\n\n\nThis is not a to-do-list, just brainstorming and a collection of random\nthoughts.\n\n\nNothing yet.",
            "title": "Stepper library"
        },
        {
            "location": "/api/Stepper/#stepper-library",
            "text": "A Library for driving stepper motors with 2, 4 or 5 phases.\nDerived from the Arduino Stepper library v1.8.0.",
            "title": "Stepper Library"
        },
        {
            "location": "/api/Stepper/#api",
            "text": "This library is a multi-instance library, it supports an arbitrary number of\nstepper motors per sketch.  The API syntax is very similar to the original C++ syntax, thanks to some c preprocessor macro magic .  The declaration supports polymorphism, so all that is needed to adopt an\nexisting sketch for use with sduino is moving the opening bracket at\nthe class declarator line and replacing the dots in the method names for\nunderscores.     Arduino method  sduino function      Stepper myStepper(steps, pin1,pin2);  Stepper (myStepper,steps,pin1,pin2);    Stepper myStepper(steps, pin1,pin2,pin3,pin4);  Stepper (myStepper,steps,pin1,pin2,pin3,pin4);    Stepper myStepper(steps, pin1,pin2,pin3,pin4,pin5);  Stepper (myStepper,steps,pin1,pin2,pin3,pin4,pin5);    myStepper.setSpeed(speed);  myStepper_setSpeed(speed);    myStepper.step(n);  myStepper_step(n);    myStepper.version();  myStepper_version();     API additions  The sduino implementation adds some extra methods to the stock Stepper\nlibrary to allow to work arounds some limitations of C code vs. C++:     Arduino method  sduino function      done automatically on start up  myStepper_activateOutputs();    not impemented  myStepper_2phase(steps,pin1,pin2);    not impemented  myStepper_4phase(steps,pin1,pin2,pin3,pin4);    not impemented  myStepper_5phase(steps,pin1,pin2,pin3,pin4,pin5);     Initializing the output pins on demand  In real C++ the internal class constructor method initializes the motor pins\nto output mode automatically at start up of the programm. In C this doesn't\nhappen automatically. Most libraries implement a begin() method for exactly\nthis purpose, but this one does not include an explicit constructor method.  Instead, the output mode is set automatically right before the very first\nmotor step. This means that the driver pins stay uninitialized and are left\nfloating from the time of power up until the first step is requested. This\nwon't be a problem in most cases as most motor drivers are using pull-up or\npull-down resistors to ensure proper signal levels.  If needed, the application could call the added  activateOutputs()  method\nin the setup() function to force an immediate port pin initialization:  setup() {\n  myStepper_activateOutputs();    // initializes the motor pins to output mode\n}  Assigning the pin connections at run time  The way the instantiation macro works requires compile-time constant values\nfor all parameters (see below in section 'Implementation Details'). In order\nto be able to (re-) configure the pin connections at run time this version\nof the library implements the functions  2phase() ,  4phase()  and 5phase() . These functions act like a constructor and allow for full\nre-initialisation of an already existing \"object\".  If you need to (re-) configure the pin connections at run time (e.g. read it\nfrom a configuration EEPROM first) you can initialize a data structure with 0  for the unknown pin numbers and set them later by calling the right\nxphase()-function:  Stepper (myStepper,0,0);\n\nsetup() {\n    ... figure out the pin numbers somehow ...\n    myStepper_4phase(stepsPerRev, pin1, pin2, pin3, pin4);\n    ...\n}\n\nloop () {\n    ...\n    myStepper_setSpeed(60);\n    myStepper_step(100);\n    ...\n}  5 phase support can be deactivated to save code space  5 phase motors are not very common, but supporting them increases the code\nsize significantly. By defining the compiler flag NO_5PHASE it is possible\nto deactivate the support for 5 phase motors. This saves 736 bytes of code\nspace. Add this line to your Makefile if you don't need 5 phase support:  CFLAGS = -DNO_5PHASE",
            "title": "API"
        },
        {
            "location": "/api/Stepper/#example",
            "text": "Notice the slightly different position of the opening parenthesis at the\n\"class constructor\" 'function' Stepper compared to the C++ instantiation.\n(available in the examples folder as  stepper_oneRevolution.c )  C-Version for use with sduino:  #include <Arduino.h>\n#include <Stepper.h>\n\n// change this to fit the number of steps per revolution for your motor\n#define stepsPerRevolution 200\n\n// initialize the stepper library on pins 8 through 11:\nStepper (myStepper,stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper_setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper_step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper_step(-stepsPerRevolution);\n  delay(500);\n}  Original Arduino C++-Sytax:  #include <Stepper.h>\n\nconst int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution\n// for your motor\n\n// initialize the stepper library on pins 8 through 11:\nStepper myStepper(stepsPerRevolution, 8, 9, 10, 11);\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper.setSpeed(60);\n}\n\nvoid loop() {\n  // step one revolution  in one direction:\n  myStepper.step(stepsPerRevolution);\n  delay(500);\n\n  // step one revolution in the other direction:\n  myStepper.step(-stepsPerRevolution);\n  delay(500);\n}",
            "title": "Example"
        },
        {
            "location": "/api/Stepper/#implementation-details",
            "text": "Technically, each Stepper instance is represented by a file-descriptor-like\nstructure. This structure is initialized by the instantiation macro Stepper . This means that all values are required to be constant values,\nknown at compile time. A  const  qualifier is not enough for SDCC, it\nrequires either a  #define  or an  enum :  const int numOfSteps = 1;   // does not work with SDCC\n#define MotorPin1  10       // ok, works\nenum { MotorPin2 = 11 };    // ok, works\n\nStepper (myStepper, numOfSteps, MotorPin1, MotorPin2);  All functions require a pointer to the stepper data structur as their first\nargument to identify the stepper instance. All this pointer handling is\nhidden by preprocessor magic, but it is still real and pure C. If you\ninsist, you can still call the 'real' functions yourself (but you gain\nnothing, the compiler produces exactly the same output).",
            "title": "Implementation details"
        },
        {
            "location": "/api/Stepper/#possible-impovements",
            "text": "This is not a to-do-list, just brainstorming and a collection of random\nthoughts.  Nothing yet.",
            "title": "Possible impovements"
        },
        {
            "location": "/api/Servo/",
            "text": "Servo Library\n\n\nThis library can control a great number of servos. It makes careful use\nof timers: the library can control 12 servos using only 1 timer.\nDerived from the Arduino Servo library v1.8.0.\n\n\nThis library has a slightly diffent user interface than the usual singleton\nlibraries. This allows for handling more than one servo per Sketch but it\nrequires some more attention when porting an existing sketch from C++ to C.\n\n\nEach Servo instance is identified by a channel-ID. In order to match the C++\nclass constructor syntax it is defined as a type \nServo\n.\n\n\nThis channel-ID is used as a file-descriptor-like value and need to be\npassed to all API functions except for \nServo_attach()\n. This function\nclaimes the next free channel number.\n\n\nExample\n\n\nRead a potentiometer on analog input 0 and set a servo pulse length between\n1000us and 2023us:\n\n\n#include <Arduino.h>\n#include <Servo.h>\n\nServo myservo;          // just a simple unsigned char to hold the channel-ID\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo = Servo_attach(9);    // attaches the servo on pin 9, returns channel-ID\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  Servo_write(myservo, val+1000);// sets the servo position\n  delay(15);\n}\n\n\n\n\nOriginal Arduino C++-Sytax:\n\n\n#include <Servo.h>\n\nServo myservo;          // create servo object to control a servo\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo.attach(9);    // attaches the servo on pin 9 to the servo object\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  myservo.write(val+1000);      // sets the servo position\n  delay(15);\n}\n\n\n\n\n\nAPI\n\n\ndata type \nServo\n: A type definition for a simple unsigned char to hold the\nchannel number returned my \nServo_attach()\n. Needed for every servo. Syntax\nidentical to the Arduino class constructor.\n\n\n\n\n\n\n\n\nArduino syntax\n\n\nsduino syntax\n\n\n\n\n\n\n\n\n\n\nServo myservo;\n\n\nServo myservo;\n\n\n\n\n\n\nmyservo.attach(pin);\n\n\nmyservo = Servo_attach(pin);\n\n\n\n\n\n\nmyservo.attach(pin,min,max);\n\n\nServo_attach_minmax(pin,min,max);\n\n\n\n\n\n\nmyservo.detach();\n\n\nServo_detach(byte channel);\n\n\n\n\n\n\nmyservo.write(val);\n\n\nServo_write(myservo, val);\n\n\n\n\n\n\nmyservo.writeMicroseconds(val);\n\n\nServo_writeMicroseconds(myservo, val);\n\n\n\n\n\n\nval = myservo.read();\n\n\nval = Servo_read(myservo);\n\n\n\n\n\n\nval = myservo.readMicroseconds();\n\n\nval = Servo_readMicroseconds(myservo);\n\n\n\n\n\n\nmyservo.attached()\n\n\nServo_attached(myservo);\n\n\n\n\n\n\n\n\nuint8_t Servo_attach(int pin);\n\nattach the given pin to the next free channel, sets pinMode, returns channel\nnumber or 0 if failure.\n\n\nuint8_t Servo_attach_minmax(int pin, int min, int max);\n\nas above but also sets min and max values for writes. \n\n\nvoid Servo_detach(byte channel);\n\n\nvoid Servo_write(byte channel, int value);\n if value is < 200 it is treated\nas an angle and scaled according the minimum and maximum pulsewidth defined\nusing the attach() function earlier, otherwise as pulse width in\nmicroseconds, unscaled.\n\n\nvoid Servo_writeMicroseconds(byte channel, int value);\n\nWrite pulse width in microseconds, unscaled.\n\n\nint Servo_read(byte channel);\n\nreturns current pulse width as an angle between 0 and 180 degrees.\n\n\nint Servo_readMicroseconds(byte channel);\n\nreturns current pulse width in microseconds for this servo (was read_us() in\nfirst Arduino release).\n\n\nbool Servo_attached(byte channel);\n\nreturn true if this servo is attached, otherwise false .\n\n\nRelationship between PWM/analog output and Servo output\n\n\nIt is not possible to use a timer for PWM and the Servo Library at the same\ntime. Since this library currently uses timer1, the PWM function\n(\nanalogWrite()\n) is disabled for the pins connected to timer1 (for the\nSTM8S103 this is pin PC3 and PC4 or digital pin 5 and 6).\n\n\nPins connected to timer2 (PA3, PD3, PD4, digital pin 2,12,13) are still\nusable for PWM output.\n\n\nPossible improvements\n\n\nA more sophisticated pseudo-OO API\n\n\nDefine a set of preprocessor macros that more OO-like definitions like this\nbecome possible:\n\n\n\n\n\n\n\n\nCurrent syntax\n\n\nOO-like syntax\n\n\nArduino syntax\n\n\n\n\n\n\n\n\n\n\nmyservo = Servo_attach(pin);\n\n\nmyservo_attach(pin);\n\n\nmyservo.attach(pin);\n\n\n\n\n\n\nServo_write(myservo, val);\n\n\nmyservo_write(val);\n\n\nmyservo_write(val);\n\n\n\n\n\n\nval = Servo_read(myservo);\n\n\nval = myservo_read();\n\n\nval = myservo_read();\n\n\n\n\n\n\n\n\nOptimizing the handle_interrupts() function\n\n\nSDCC compiles this function very inefficiently. The code size is around 500\nBytes, and it is executed as part of the CC interrupt routine. Expected CPU\nload for a full servo group of 12 servos is approx. 2%.\n\n\n(Calculated for 16MHz CPU clock, 13 interrupts every 20ms = 650\ninterrupts/sec, approx. 500 clock cycles each)\n\n\nUsing more than one CC channel per timer\n\n\nit might be possible to use all capture+compare (CC) channels of one timer\nat the same time, attaching one servo group to each CC-channel. This way it\nwould be possible to serve up to 48 servos using the four CC-channels of\ntimer TIM1. Monitoring the repetion period might become a little complex, as\nit must be ensured that all servos on all channels have finshed before.",
            "title": "Servo library"
        },
        {
            "location": "/api/Servo/#servo-library",
            "text": "This library can control a great number of servos. It makes careful use\nof timers: the library can control 12 servos using only 1 timer.\nDerived from the Arduino Servo library v1.8.0.  This library has a slightly diffent user interface than the usual singleton\nlibraries. This allows for handling more than one servo per Sketch but it\nrequires some more attention when porting an existing sketch from C++ to C.  Each Servo instance is identified by a channel-ID. In order to match the C++\nclass constructor syntax it is defined as a type  Servo .  This channel-ID is used as a file-descriptor-like value and need to be\npassed to all API functions except for  Servo_attach() . This function\nclaimes the next free channel number.",
            "title": "Servo Library"
        },
        {
            "location": "/api/Servo/#example",
            "text": "Read a potentiometer on analog input 0 and set a servo pulse length between\n1000us and 2023us:  #include <Arduino.h>\n#include <Servo.h>\n\nServo myservo;          // just a simple unsigned char to hold the channel-ID\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo = Servo_attach(9);    // attaches the servo on pin 9, returns channel-ID\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  Servo_write(myservo, val+1000);// sets the servo position\n  delay(15);\n}  Original Arduino C++-Sytax:  #include <Servo.h>\n\nServo myservo;          // create servo object to control a servo\n\nint val;                // variable to read the value from the analog pin\n\nvoid setup() {\n  myservo.attach(9);    // attaches the servo on pin 9 to the servo object\n}\n\nvoid loop() {\n  val = analogRead(0);          // reads the value of the potentiometer\n  myservo.write(val+1000);      // sets the servo position\n  delay(15);\n}",
            "title": "Example"
        },
        {
            "location": "/api/Servo/#api",
            "text": "data type  Servo : A type definition for a simple unsigned char to hold the\nchannel number returned my  Servo_attach() . Needed for every servo. Syntax\nidentical to the Arduino class constructor.     Arduino syntax  sduino syntax      Servo myservo;  Servo myservo;    myservo.attach(pin);  myservo = Servo_attach(pin);    myservo.attach(pin,min,max);  Servo_attach_minmax(pin,min,max);    myservo.detach();  Servo_detach(byte channel);    myservo.write(val);  Servo_write(myservo, val);    myservo.writeMicroseconds(val);  Servo_writeMicroseconds(myservo, val);    val = myservo.read();  val = Servo_read(myservo);    val = myservo.readMicroseconds();  val = Servo_readMicroseconds(myservo);    myservo.attached()  Servo_attached(myservo);     uint8_t Servo_attach(int pin); \nattach the given pin to the next free channel, sets pinMode, returns channel\nnumber or 0 if failure.  uint8_t Servo_attach_minmax(int pin, int min, int max); \nas above but also sets min and max values for writes.   void Servo_detach(byte channel);  void Servo_write(byte channel, int value);  if value is < 200 it is treated\nas an angle and scaled according the minimum and maximum pulsewidth defined\nusing the attach() function earlier, otherwise as pulse width in\nmicroseconds, unscaled.  void Servo_writeMicroseconds(byte channel, int value); \nWrite pulse width in microseconds, unscaled.  int Servo_read(byte channel); \nreturns current pulse width as an angle between 0 and 180 degrees.  int Servo_readMicroseconds(byte channel); \nreturns current pulse width in microseconds for this servo (was read_us() in\nfirst Arduino release).  bool Servo_attached(byte channel); \nreturn true if this servo is attached, otherwise false .",
            "title": "API"
        },
        {
            "location": "/api/Servo/#relationship-between-pwmanalog-output-and-servo-output",
            "text": "It is not possible to use a timer for PWM and the Servo Library at the same\ntime. Since this library currently uses timer1, the PWM function\n( analogWrite() ) is disabled for the pins connected to timer1 (for the\nSTM8S103 this is pin PC3 and PC4 or digital pin 5 and 6).  Pins connected to timer2 (PA3, PD3, PD4, digital pin 2,12,13) are still\nusable for PWM output.",
            "title": "Relationship between PWM/analog output and Servo output"
        },
        {
            "location": "/api/Servo/#possible-improvements",
            "text": "A more sophisticated pseudo-OO API  Define a set of preprocessor macros that more OO-like definitions like this\nbecome possible:     Current syntax  OO-like syntax  Arduino syntax      myservo = Servo_attach(pin);  myservo_attach(pin);  myservo.attach(pin);    Servo_write(myservo, val);  myservo_write(val);  myservo_write(val);    val = Servo_read(myservo);  val = myservo_read();  val = myservo_read();     Optimizing the handle_interrupts() function  SDCC compiles this function very inefficiently. The code size is around 500\nBytes, and it is executed as part of the CC interrupt routine. Expected CPU\nload for a full servo group of 12 servos is approx. 2%.  (Calculated for 16MHz CPU clock, 13 interrupts every 20ms = 650\ninterrupts/sec, approx. 500 clock cycles each)  Using more than one CC channel per timer  it might be possible to use all capture+compare (CC) channels of one timer\nat the same time, attaching one servo group to each CC-channel. This way it\nwould be possible to serve up to 48 servos using the four CC-channels of\ntimer TIM1. Monitoring the repetion period might become a little complex, as\nit must be ensured that all servos on all channels have finshed before.",
            "title": "Possible improvements"
        },
        {
            "location": "/hardware/flashtool/",
            "text": "Flash tool\n\n\nYou need a special flash tools in order to program the CPU. As far as I know\nthere is no third-party product or software that implements the needed\ncommunication protocol. So you can't just use a regular Arduino board as a\nflash tool as you could for the ATmega. But this is not a problem, as these\ntools are are easily available and unbeliveably cheap (well under $3 on\naliexpress, search for st-link).\n\n\nThere are two versions of the ST-Link V2 compatible flash tool available:\nOne in a USB-Drive-like metal housing (often pink or blue) and one made by\nBaite in a green plastic housing. Both work well, but they use a different\npinout.\n\n\n\n\nBoth flash tools support the SWIM protocol for STM8 CPUs and the SWD\nprotocol for the STM32 CPUs. The programmer from Baite additionally supports\nJTAG and is slightly superior to the more common one in the metal housing.\nMore information on the hardware and the pinouts:\nhttps://wiki.cuvoodoo.info/doku.php?id=jtag\n\n\nPinout\n\n\nPinout of Chinese ST-Link V2-clone made by Baite with green plasic housing\n(supports SWIM, SWD and JTAG):\n\n\n            +-----+\n    T_JRST  | 1  2| 3V3\n    5V      | 3  4| T_JTCK/T_SWCLK\n    SWIM      5  6| T_JTMS/T_SWDIO\n    GND     | 7  8| T_JTDO\n    SWIM RST| 9 10| T_JTDI\n            +-----+\n\n\n\nPinout of Chinese ST-Link V2-clone with metal housing (supports SWIM and\nSWD):\n\n\n            +-----+\n    RST     | 1  2| SWDIO\n    GND     | 3  4| GND\n    SWIM      5  6| SWCLK\n    3V3     | 7  8| 3V3\n    5V      | 9 10| 5V\n            +-----+\n\n\n\nInstallation for Linux\n\n\nSave this as root in in \n/etc/udev/rules.d/99-stlink.rules\n:\n\n\n# ST-Link/V2 programming adapter\n\n# ST-Link V1, if using a STM8S discovery board\n# important: It needs a special entry in /etc/modprob/blacklist\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"\n\n\n\nUsing the STM8S-Discovery board as a flash programmer is a special case and\nrequires \nsome additional\nblacklisting\n.\n\n\nInstallation for Windows\n\n\nDownload and install the ST-Link/v2 driver \nbefore you plug in the flash\ntool\n:\n\nSTSW-LINK009 driver download\n\n(Registration required, but very easy)\n\n\nConnection to the CPU board\n\n\nThe pinout of the SWIM connector P3 on my STM8S103 breakout board fits the\npinout of the flash tool in the metal housing perfectly:\n\n\n\n\n\n\n\n\nSignal\n\n\nSWIM connector P3\n\n\nBaite ST-Link\n\n\nMetal ST-Link\n\n\n\n\n\n\n\n\n\n\n3V3\n\n\n1\n\n\n2\n\n\n7\n\n\n\n\n\n\nSWIM\n\n\n2\n\n\n5\n\n\n5\n\n\n\n\n\n\nGND\n\n\n3\n\n\n7\n\n\n3\n\n\n\n\n\n\nNRST\n\n\n4\n\n\n9\n\n\n1\n\n\n\n\n\n\n\n\nThe Discovery boards made by ST all feature a ST-Link interface as well, but\nonly the Discovery STM8S105 supports the SWIM protocol. The Discovery\nSTM32F0308 implements SWD only and is not usable for the STM8.\n\n\n\n\n\n\n\n\nPin out CN3\n\n\nSWD\n\n\n\n\n\n\n\n\n\n\n1\n\n\n? detect oder so?\n\n\n\n\n\n\n2\n\n\nJTCK/SWCLK\n\n\n\n\n\n\n3\n\n\nGND\n\n\n\n\n\n\n4\n\n\nJTMS/SWDIO\n\n\n\n\n\n\n5\n\n\nNRST\n\n\n\n\n\n\n6\n\n\nSWO",
            "title": "Flash tool"
        },
        {
            "location": "/hardware/flashtool/#flash-tool",
            "text": "You need a special flash tools in order to program the CPU. As far as I know\nthere is no third-party product or software that implements the needed\ncommunication protocol. So you can't just use a regular Arduino board as a\nflash tool as you could for the ATmega. But this is not a problem, as these\ntools are are easily available and unbeliveably cheap (well under $3 on\naliexpress, search for st-link).  There are two versions of the ST-Link V2 compatible flash tool available:\nOne in a USB-Drive-like metal housing (often pink or blue) and one made by\nBaite in a green plastic housing. Both work well, but they use a different\npinout.   Both flash tools support the SWIM protocol for STM8 CPUs and the SWD\nprotocol for the STM32 CPUs. The programmer from Baite additionally supports\nJTAG and is slightly superior to the more common one in the metal housing.\nMore information on the hardware and the pinouts:\nhttps://wiki.cuvoodoo.info/doku.php?id=jtag",
            "title": "Flash tool"
        },
        {
            "location": "/hardware/flashtool/#pinout",
            "text": "Pinout of Chinese ST-Link V2-clone made by Baite with green plasic housing\n(supports SWIM, SWD and JTAG):              +-----+\n    T_JRST  | 1  2| 3V3\n    5V      | 3  4| T_JTCK/T_SWCLK\n    SWIM      5  6| T_JTMS/T_SWDIO\n    GND     | 7  8| T_JTDO\n    SWIM RST| 9 10| T_JTDI\n            +-----+  Pinout of Chinese ST-Link V2-clone with metal housing (supports SWIM and\nSWD):              +-----+\n    RST     | 1  2| SWDIO\n    GND     | 3  4| GND\n    SWIM      5  6| SWCLK\n    3V3     | 7  8| 3V3\n    5V      | 9 10| 5V\n            +-----+",
            "title": "Pinout"
        },
        {
            "location": "/hardware/flashtool/#installation-for-linux",
            "text": "Save this as root in in  /etc/udev/rules.d/99-stlink.rules :  # ST-Link/V2 programming adapter\n\n# ST-Link V1, if using a STM8S discovery board\n# important: It needs a special entry in /etc/modprob/blacklist\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n# ST-Link/V2, the china adapter with the green plastic housing\nATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"  Using the STM8S-Discovery board as a flash programmer is a special case and\nrequires  some additional\nblacklisting .",
            "title": "Installation for Linux"
        },
        {
            "location": "/hardware/flashtool/#installation-for-windows",
            "text": "Download and install the ST-Link/v2 driver  before you plug in the flash\ntool : STSW-LINK009 driver download \n(Registration required, but very easy)",
            "title": "Installation for Windows"
        },
        {
            "location": "/hardware/flashtool/#connection-to-the-cpu-board",
            "text": "The pinout of the SWIM connector P3 on my STM8S103 breakout board fits the\npinout of the flash tool in the metal housing perfectly:     Signal  SWIM connector P3  Baite ST-Link  Metal ST-Link      3V3  1  2  7    SWIM  2  5  5    GND  3  7  3    NRST  4  9  1     The Discovery boards made by ST all feature a ST-Link interface as well, but\nonly the Discovery STM8S105 supports the SWIM protocol. The Discovery\nSTM32F0308 implements SWD only and is not usable for the STM8.     Pin out CN3  SWD      1  ? detect oder so?    2  JTCK/SWCLK    3  GND    4  JTMS/SWDIO    5  NRST    6  SWO",
            "title": "Connection to the CPU board"
        },
        {
            "location": "/hardware/stm8blue/",
            "text": "Generic STM8S103 breakout board\n\n\nThese simple breakout boards are available on aliexpress for well under one\nDollar (I got mine for 67 cent each, including shipping from China). They\nare my original development platform.\n\n\n\n\nThey are very similar to the \nESP14 Wifi-boards\n and\nmost programs will work fine on those chinese gems as well.\n\n\nThe STM8S103 breakout boards are build around a CPU STM8S103F3P6 with 16MHz\ninternal oscillator, 8kB flash, 1kB RAM, and 640 byte EEPROM. The CPU\nincludes a UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 14 I/O pins -\nquite similar to an Atmel ATmega8.\n\n\nOne (red) LED is connected to GPIO PB5 (CPU pin 11). The push button is for\nreset. The CPU runs on 3.3V, a linear regulator is integrated on the\nboard. The micro USB connector is only for (5V) power supply, the data lines\nare not connected.\n\n\nAll CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm,\nperfect for breadboards).\n\n\n\n\nMy breakout boards came preprogrammed with a blink program and with active\nwrite protection bits. For unlocking before first use:\n\n\nstm8flash -cstlinkv2 -pstm8s103?3 -u\n\n\n\n\nConnection to the flash tool\n\n\nI am using the ST-Link V2 compatible flash tool in the green plastic\nhousing. The one in the metal housing uses a different pinout.\n\n\nConnection to the flashtool:\n\n\n\n\n\n\n\n\nSignal name\n\n\nP3 on CPU board\n\n\nGreen flash tool\n\n\nMetal flash tool\n\n\n\n\n\n\n\n\n\n\n3V3\n\n\n1\n\n\n2\n\n\n7\n\n\n\n\n\n\nSWIM\n\n\n2\n\n\n5\n\n\n5\n\n\n\n\n\n\nGND\n\n\n3\n\n\n7\n\n\n3\n\n\n\n\n\n\nNRST\n\n\n4\n\n\n9\n\n\n1\n\n\n\n\n\n\n\n\nPin number mappings\n\n\nThe Arduino environment uses its own pin numbering scheme independent from\nthe physical CPU pin numbers. Many Arduino sketches and libraries contain\nhard-coded assumptions about the number of pins with special functions.\nIdeally, all these numbers would be the same and all programs could be\ncompiled without changes.\n\n\nHere\n I discuss some possible pin mapping\nschemes and check how close we could get the the ideal mapping.\nUnfortunatly, it turns out that a perfect mapping is not possible.\n\n\nIn the end I chose a simple geometric numbering for the square UFQFPN20\npackage starting with port pin PA1 and counting up from 0. This results in\nthis mapping:\n\n\n\n\nThe pins D3/D4 (SDA/SCL, PB5/PB4) are different from the others as they are\ntrue open drain pins. That means, they only can drive the output low or\nopen. To drive it high, they require the of an external pull-up resistor.\nThis is the reason why the LED on this breakout is connected between +3.3V\nand the pins and not between the pin GND as usual. This way it is possible\nto drive the LED by writing a zero to the output register.\n\n\n\n\n\n\n\n\nsduino pin\n\n\nSTM8S103 CPU port pin\n\n\n\n\n\n\n\n\n\n\n0-2\n\n\nPA1-PA3 (PA1 and PA2 only weak output drivers)\n\n\n\n\n\n\n3-4\n\n\nPB5-PB4 (reverse order)\n\n\n\n\n\n\n5-9\n\n\nPC3-PC7\n\n\n\n\n\n\n10-15\n\n\nPD1-PD6\n\n\n\n\n\n\n\n\nserial: 14,15\n\nSPI: 2,7,8,9\n\nI2C: 3,4 (true open drain. can't drive a high signal without an external\npull-up resistor)\nAnalog: 6,11,12,14,15\n\nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping)  \n\n\n\n\nEasy and logical for use on a breadboard\n\n\nVery clear and logical port pin ordering\n\n\nAnalog pins are still scattered around\n\n\nTX and RX would be the rarely used analog pin numbers A3/A4 at\n   the end of the analog pin number list\n\n\nAt least the analog pins are in data sheet order\n\n\nAll functions use totally different pin numbers than Arduino\n\n\n\n\nI am still not really happy with this mapping. Instead of simplifing things\nit only adds another layer of abstraction and confusion. To avoid this I\nadded definitions for the regular CPU pin names like \nPA1\n and \nPD2\n. In the\nend, this notation seems to be a lot easier to me. I am open for suggestions\nfor a better pin number mapping.\n\n\nThe chosen pin mapping for the STM8S103 (possible alternate function in\nparatheses):\n\n\n\n\n\n\n\n\nPhys. STM8 pin\n\n\nName\n\n\nFunctions\n\n\nGeometrical mapping\n\n\nspecial funcion\n\n\n\n\n\n\n\n\n\n\n1\n\n\nPD4\n\n\nUART_CLK/T2-1/beep\n\n\n13\n\n\nPWM\n\n\n\n\n\n\n2\n\n\nPD5\n\n\nTX/Ain5\n\n\n14\n\n\nAnalog A3\n\n\n\n\n\n\n3\n\n\nPD6\n\n\nRX/Ain6\n\n\n15\n\n\nAnalog A4\n\n\n\n\n\n\n5\n\n\nPA1\n\n\n(OscIn, kein HS)\n\n\n0\n\n\n\n\n\n\n\n\n6\n\n\nPA2\n\n\n(OscIn, kein HS)\n\n\n1\n\n\n\n\n\n\n\n\n10\n\n\nPA3\n\n\nSS/T2-3\n\n\n2\n\n\nPWM\n\n\n\n\n\n\n11\n\n\nPB5\n\n\nSDA    LED\n\n\n3\n\n\n\n\n\n\n\n\n12\n\n\nPB4\n\n\nSCL\n\n\n4\n\n\n\n\n\n\n\n\n13\n\n\nPC3\n\n\nT1-3/[T1-n1]\n\n\n5\n\n\nPWM, (n~)\n\n\n\n\n\n\n14\n\n\nPC4\n\n\nT1-4/Ain2/[T1-n2]\n\n\n6\n\n\nPWM, Analog A0, (n~)\n\n\n\n\n\n\n15\n\n\nPC5\n\n\nSCK/[T2-1]\n\n\n7\n\n\n(~)\n\n\n\n\n\n\n16\n\n\nPC6\n\n\nMOSI/[T1-1]\n\n\n8\n\n\n(~)\n\n\n\n\n\n\n17\n\n\nPC7\n\n\nMISO/[T1-2]\n\n\n9\n\n\n(~)\n\n\n\n\n\n\n18\n\n\nPD1\n\n\n(SWIM)\n\n\n10\n\n\n\n\n\n\n\n\n19\n\n\nPD2\n\n\nAin3/[T2-3]\n\n\n11\n\n\nAnalog A1, (~~)\n\n\n\n\n\n\n20\n\n\nPD3\n\n\nAin4/T2-2\n\n\n12\n\n\nPWM, Analog A2",
            "title": "Generic STM8S103 breakout board (stm8blue)"
        },
        {
            "location": "/hardware/stm8blue/#generic-stm8s103-breakout-board",
            "text": "These simple breakout boards are available on aliexpress for well under one\nDollar (I got mine for 67 cent each, including shipping from China). They\nare my original development platform.   They are very similar to the  ESP14 Wifi-boards  and\nmost programs will work fine on those chinese gems as well.  The STM8S103 breakout boards are build around a CPU STM8S103F3P6 with 16MHz\ninternal oscillator, 8kB flash, 1kB RAM, and 640 byte EEPROM. The CPU\nincludes a UART, SPI, I2C, PWM, 10 bit ADC, 3 timer, and up to 14 I/O pins -\nquite similar to an Atmel ATmega8.  One (red) LED is connected to GPIO PB5 (CPU pin 11). The push button is for\nreset. The CPU runs on 3.3V, a linear regulator is integrated on the\nboard. The micro USB connector is only for (5V) power supply, the data lines\nare not connected.  All CPU pins are easily accessible on (optional) pin headers (pitch 2.54mm,\nperfect for breadboards).   My breakout boards came preprogrammed with a blink program and with active\nwrite protection bits. For unlocking before first use:  stm8flash -cstlinkv2 -pstm8s103?3 -u",
            "title": "Generic STM8S103 breakout board"
        },
        {
            "location": "/hardware/stm8blue/#connection-to-the-flash-tool",
            "text": "I am using the ST-Link V2 compatible flash tool in the green plastic\nhousing. The one in the metal housing uses a different pinout.  Connection to the flashtool:     Signal name  P3 on CPU board  Green flash tool  Metal flash tool      3V3  1  2  7    SWIM  2  5  5    GND  3  7  3    NRST  4  9  1",
            "title": "Connection to the flash tool"
        },
        {
            "location": "/hardware/stm8blue/#pin-number-mappings",
            "text": "The Arduino environment uses its own pin numbering scheme independent from\nthe physical CPU pin numbers. Many Arduino sketches and libraries contain\nhard-coded assumptions about the number of pins with special functions.\nIdeally, all these numbers would be the same and all programs could be\ncompiled without changes.  Here  I discuss some possible pin mapping\nschemes and check how close we could get the the ideal mapping.\nUnfortunatly, it turns out that a perfect mapping is not possible.  In the end I chose a simple geometric numbering for the square UFQFPN20\npackage starting with port pin PA1 and counting up from 0. This results in\nthis mapping:   The pins D3/D4 (SDA/SCL, PB5/PB4) are different from the others as they are\ntrue open drain pins. That means, they only can drive the output low or\nopen. To drive it high, they require the of an external pull-up resistor.\nThis is the reason why the LED on this breakout is connected between +3.3V\nand the pins and not between the pin GND as usual. This way it is possible\nto drive the LED by writing a zero to the output register.     sduino pin  STM8S103 CPU port pin      0-2  PA1-PA3 (PA1 and PA2 only weak output drivers)    3-4  PB5-PB4 (reverse order)    5-9  PC3-PC7    10-15  PD1-PD6     serial: 14,15 \nSPI: 2,7,8,9 \nI2C: 3,4 (true open drain. can't drive a high signal without an external\npull-up resistor)\nAnalog: 6,11,12,14,15 \nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping)     Easy and logical for use on a breadboard  Very clear and logical port pin ordering  Analog pins are still scattered around  TX and RX would be the rarely used analog pin numbers A3/A4 at\n   the end of the analog pin number list  At least the analog pins are in data sheet order  All functions use totally different pin numbers than Arduino   I am still not really happy with this mapping. Instead of simplifing things\nit only adds another layer of abstraction and confusion. To avoid this I\nadded definitions for the regular CPU pin names like  PA1  and  PD2 . In the\nend, this notation seems to be a lot easier to me. I am open for suggestions\nfor a better pin number mapping.  The chosen pin mapping for the STM8S103 (possible alternate function in\nparatheses):     Phys. STM8 pin  Name  Functions  Geometrical mapping  special funcion      1  PD4  UART_CLK/T2-1/beep  13  PWM    2  PD5  TX/Ain5  14  Analog A3    3  PD6  RX/Ain6  15  Analog A4    5  PA1  (OscIn, kein HS)  0     6  PA2  (OscIn, kein HS)  1     10  PA3  SS/T2-3  2  PWM    11  PB5  SDA    LED  3     12  PB4  SCL  4     13  PC3  T1-3/[T1-n1]  5  PWM, (n~)    14  PC4  T1-4/Ain2/[T1-n2]  6  PWM, Analog A0, (n~)    15  PC5  SCK/[T2-1]  7  (~)    16  PC6  MOSI/[T1-1]  8  (~)    17  PC7  MISO/[T1-2]  9  (~)    18  PD1  (SWIM)  10     19  PD2  Ain3/[T2-3]  11  Analog A1, (~~)    20  PD3  Ain4/T2-2  12  PWM, Analog A2",
            "title": "Pin number mappings"
        },
        {
            "location": "/hardware/esp14/",
            "text": "ESP-14\n\n\nAn ESP-8266 Wifi-Controller together with a STM8S003 CPU for about $2 -\nincredible.  Since the STM8S003 is almost identical to the STM8S103 used on\nthe \nSTM8S103 breakout boards\n all software runs here as well.\n\n\nUsing the same pin numbering scheme as with the stm8blue boards it looks\nlike this:\n\n\n\n\nDifferences between the '003 and the '103 CPUs\n\n\nVery slim. All differences that I could find so far:\n\n\n\n\n\n\n\n\nFeature\n\n\nSTM8S003\n\n\nSTM8S103\n\n\n\n\n\n\n\n\n\n\nEEPROM size\n\n\n128 Bytes\n\n\n640 Bytes\n\n\n\n\n\n\n\n\nI am not sure why the '003 is sold for half the price, or, to put it the\nother way around, why anybody should choose the '103 at all. Did I miss an\nimportant difference?\n\n\nUsing the Wifi connection\n\n\nThe ESP-14 is basically an ESP-01 Wifi-module together with a STM8S breakout\nboard combined into one PCB. The ESP part comes preprogrammed with the\nusual ESP AT-Firmware and is connected to the RX/TX pins of the STM8S.\n\n\nIt feels like having a classic ATmega8-Arduino with a build-in ESP-01\nmodule. Using the \nWiFiEsp library\n\nwe could have a programming experience very similar to using an Arduino with\na Wifi-shield or an Arduino Yun.\n\n\nThe main problem is the limited flash space of the '003. Even the very basic\nWebServer example that comes with the WiFiEsp library needs more then 14kB\nflash and more than 1kB RAM when compiled for an Arduino Uno. Even if the\nlibrary could be carefully optimized to fit into the 8kB flash of an '003 -\nthere would be no space left for the actual user code.\n\n\nIt is still possible to do very simple task by just sending AT-strings to\nthe ESP. But here we are definitly leaving Ardunio territory. Here we have\nto start from scratch and do it all by ourself. This is not going to be\nbeginner-friendly anymore.\n\n\nThe major remaining advantage of the STM8S over the ESP is power efficiency.\nThe STM8S runs on almost nothing, while the ESP draws anything between 50\nand 200mA even for the simplest tasks.\n\n\nIn most cases you might want to implement the external communication part of\nthe application on the ESP, using the\n\nESP8266 Arduino port\n.\n\n\nThe STM8S is better suited to local control and measurement and other\nenergy- and time-critical tasks. Both CPUs use separate power supply inputs.\nUsing an additional PMOS transistor the STM8S could control the power supply\nfor the ESP and help extending battery life by activating the big brother\nonly when its services are actually required.\n\n\nPoor design choice\n\n\nOverall, the '003 is a very questionable CPU choice by AI Thinker. The '003\nis clearly one of the cheapest CPUs on the market, but the applications for\nthis module are heavily restricted the the small flash memory.\n\n\nWhy didn't they use an ATmega328? Just one dollar more and the whole Arduino\nuniverse opens up. Or at least an STM8S005K6T6C, offering 32kB flash and 2kB\nRAM for only 40 cents more, if you want to go really cheap.\n\n\nAnd why would you need an external PMOS to control the ESP power supply?\nWhy is this not included on the PCB already? This could the big killer\nfeature of the current combination.\n\n\nThe upside\n\n\nHaving a beefy 32 bit CPU and using it as an I/O-coprocessor while running\nthe main application on an resticted 8-bitter is a weired concept. Things\nlike the Arduino Yun or the Arduino WiFi-shield don't make too much sense.\n\n\nIt is much more sensible to use the big CPU to control the small one than\nthe other way around. Maybe this board can help to promote that concept.",
            "title": "ESP14: Wifi board, STM8S003"
        },
        {
            "location": "/hardware/esp14/#esp-14",
            "text": "An ESP-8266 Wifi-Controller together with a STM8S003 CPU for about $2 -\nincredible.  Since the STM8S003 is almost identical to the STM8S103 used on\nthe  STM8S103 breakout boards  all software runs here as well.  Using the same pin numbering scheme as with the stm8blue boards it looks\nlike this:",
            "title": "ESP-14"
        },
        {
            "location": "/hardware/esp14/#differences-between-the-003-and-the-103-cpus",
            "text": "Very slim. All differences that I could find so far:     Feature  STM8S003  STM8S103      EEPROM size  128 Bytes  640 Bytes     I am not sure why the '003 is sold for half the price, or, to put it the\nother way around, why anybody should choose the '103 at all. Did I miss an\nimportant difference?",
            "title": "Differences between the '003 and the '103 CPUs"
        },
        {
            "location": "/hardware/esp14/#using-the-wifi-connection",
            "text": "The ESP-14 is basically an ESP-01 Wifi-module together with a STM8S breakout\nboard combined into one PCB. The ESP part comes preprogrammed with the\nusual ESP AT-Firmware and is connected to the RX/TX pins of the STM8S.  It feels like having a classic ATmega8-Arduino with a build-in ESP-01\nmodule. Using the  WiFiEsp library \nwe could have a programming experience very similar to using an Arduino with\na Wifi-shield or an Arduino Yun.  The main problem is the limited flash space of the '003. Even the very basic\nWebServer example that comes with the WiFiEsp library needs more then 14kB\nflash and more than 1kB RAM when compiled for an Arduino Uno. Even if the\nlibrary could be carefully optimized to fit into the 8kB flash of an '003 -\nthere would be no space left for the actual user code.  It is still possible to do very simple task by just sending AT-strings to\nthe ESP. But here we are definitly leaving Ardunio territory. Here we have\nto start from scratch and do it all by ourself. This is not going to be\nbeginner-friendly anymore.  The major remaining advantage of the STM8S over the ESP is power efficiency.\nThe STM8S runs on almost nothing, while the ESP draws anything between 50\nand 200mA even for the simplest tasks.  In most cases you might want to implement the external communication part of\nthe application on the ESP, using the ESP8266 Arduino port .  The STM8S is better suited to local control and measurement and other\nenergy- and time-critical tasks. Both CPUs use separate power supply inputs.\nUsing an additional PMOS transistor the STM8S could control the power supply\nfor the ESP and help extending battery life by activating the big brother\nonly when its services are actually required.",
            "title": "Using the Wifi connection"
        },
        {
            "location": "/hardware/esp14/#poor-design-choice",
            "text": "Overall, the '003 is a very questionable CPU choice by AI Thinker. The '003\nis clearly one of the cheapest CPUs on the market, but the applications for\nthis module are heavily restricted the the small flash memory.  Why didn't they use an ATmega328? Just one dollar more and the whole Arduino\nuniverse opens up. Or at least an STM8S005K6T6C, offering 32kB flash and 2kB\nRAM for only 40 cents more, if you want to go really cheap.  And why would you need an external PMOS to control the ESP power supply?\nWhy is this not included on the PCB already? This could the big killer\nfeature of the current combination.",
            "title": "Poor design choice"
        },
        {
            "location": "/hardware/esp14/#the-upside",
            "text": "Having a beefy 32 bit CPU and using it as an I/O-coprocessor while running\nthe main application on an resticted 8-bitter is a weired concept. Things\nlike the Arduino Yun or the Arduino WiFi-shield don't make too much sense.  It is much more sensible to use the big CPU to control the small one than\nthe other way around. Maybe this board can help to promote that concept.",
            "title": "The upside"
        },
        {
            "location": "/hardware/stm8sdiscovery/",
            "text": "STM8S Discovery\n\n\nA widespread evaluation board made by ST. All CPU pins are easily accessible\non 2x6 pin headers. It costs only $9 and includes a ST-Link/v1 flash\nprogrammer on board.\n\n\nIt should work now, but the support is not thoroughly tested. At least\nBlink.c is known to work already.\n\n\nSTM8S105C6T6 microcontroller, 32 KB Flash, 2 KB RAM, 1 KB EEPROM \n\n\n\n\nLED on PD0, active low.\n\n\nTouch button on PC1, PC2, PC3\n\n\nexternal crystal 16MHz on PA1/PA2\n\n\n\n\nThe touch pins PC1 and PC3 (Arduino-Pin 24 and 26) are not connected to the\npin header on the board. To use them as I/O-pins you need to modify some\nsolder bridges (See STM8S-Discovery user manual).\n\n\nSWIM connector\n\n\nPinout of CN7 SWIM connector\n\n\n\n\n\n\n\n\nPin\n\n\nSignal\n\n\n\n\n\n\n\n\n\n\n1\n\n\nVdd (3.3V)\n\n\n\n\n\n\n2\n\n\nSWIM\n\n\n\n\n\n\n3\n\n\nGND\n\n\n\n\n\n\n4\n\n\nNRST\n\n\n\n\n\n\n\n\nUsage with Linux and stm8flash\n\n\nThe discovery board implements two USB devices: A ST-LINK/V1 interface and a\n(not very useful) mass storage device with some links to the ST website. The\nimplementation of this mass storage device is very buggy and renders the\nhole board useless. You need to make modprobe to ignore it by adding this\nline to /etc/modprobe.conf or by adding a file\n/etc/modprobe.d/stdiscovery.conf with this line:\n\n\n    options usb-storage quirks=0483:3744:i\n\n\n\n\nUnplug the Discovery board and unload the usb mass storage driver with\n\n\n    modprobe -r uas usb_storage\n\n\n\n\nIf you can't unload the usb_storage drive because it is in use with other\ndevices you can temporary trigger the same effect by this line:\n\n\n    echo \"0483:3744:i\" >/sys/module/usb_storage/parameters/quirks\n\n\n\n\nThe second step is to add a new udev rule in order to access the USB port.\nSave this as root in in \n/etc/udev/rules.d/99-stlink.rules\n:\n\n\n    # ST-Link/V2 programming adapter\n\n    # ST-Link V1, if using a STM8S discovery board\n    # important: It needs a special entry in /etc/modprobe.d\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n    # ST-Link/V2, the china adapter with the green plastic housing\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"\n\n\n\n\nFinally, it is time to (re-) connect the board. Now dmesg should show that\nthe mass storage device of the Discovery board is ignored:\n\n\n    [  815.228928] usbcore: deregistering interface driver uas\n    [  815.229201] usbcore: deregistering interface driver usb-storage\n    [  823.001086] usb 1-3: new full-speed USB device number 7 using xhci_hcd\n    [  823.374719] usb 1-3: New USB device found, idVendor=0483, idProduct=3744\n    [  823.374724] usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n    [  823.374726] usb 1-3: Product: STM32 STLink\n    [  823.374728] usb 1-3: Manufacturer: STMicroelectronics\n    [  823.374730] usb 1-3: SerialNumber: W\\xffffffc3\\xffffffbf\\xffffffbfp\\x06reWW7\\x18\\x12g\n    [  823.746878] usb-storage 1-3:1.0: USB Mass Storage device detected\n    [  823.748299] usb-storage 1-3:1.0: device ignored\n    [  823.748453] usbcore: registered new interface driver usb-storage\n    [  823.771094] usbcore: registered new interface driver uas\n\n\n\n\nLet's read the preinstalled firmware of the STM8S105:\n\n\n    stm8flash -cstlink \"-pstm8s105?6\" -r flash.img\n\n\n\n\nFurther reading\n\n\nAN3332\n:\nGenerating PWM signals using STM8S-DISCOVERY \n\n\nAN3259\n:\nRS232 communications with a terminal using the STM8S-DISCOVERY",
            "title": "STM8S105Discovery: Evaluation board made my ST"
        },
        {
            "location": "/hardware/stm8sdiscovery/#stm8s-discovery",
            "text": "A widespread evaluation board made by ST. All CPU pins are easily accessible\non 2x6 pin headers. It costs only $9 and includes a ST-Link/v1 flash\nprogrammer on board.  It should work now, but the support is not thoroughly tested. At least\nBlink.c is known to work already.  STM8S105C6T6 microcontroller, 32 KB Flash, 2 KB RAM, 1 KB EEPROM    LED on PD0, active low.  Touch button on PC1, PC2, PC3  external crystal 16MHz on PA1/PA2   The touch pins PC1 and PC3 (Arduino-Pin 24 and 26) are not connected to the\npin header on the board. To use them as I/O-pins you need to modify some\nsolder bridges (See STM8S-Discovery user manual).",
            "title": "STM8S Discovery"
        },
        {
            "location": "/hardware/stm8sdiscovery/#swim-connector",
            "text": "Pinout of CN7 SWIM connector     Pin  Signal      1  Vdd (3.3V)    2  SWIM    3  GND    4  NRST",
            "title": "SWIM connector"
        },
        {
            "location": "/hardware/stm8sdiscovery/#usage-with-linux-and-stm8flash",
            "text": "The discovery board implements two USB devices: A ST-LINK/V1 interface and a\n(not very useful) mass storage device with some links to the ST website. The\nimplementation of this mass storage device is very buggy and renders the\nhole board useless. You need to make modprobe to ignore it by adding this\nline to /etc/modprobe.conf or by adding a file\n/etc/modprobe.d/stdiscovery.conf with this line:      options usb-storage quirks=0483:3744:i  Unplug the Discovery board and unload the usb mass storage driver with      modprobe -r uas usb_storage  If you can't unload the usb_storage drive because it is in use with other\ndevices you can temporary trigger the same effect by this line:      echo \"0483:3744:i\" >/sys/module/usb_storage/parameters/quirks  The second step is to add a new udev rule in order to access the USB port.\nSave this as root in in  /etc/udev/rules.d/99-stlink.rules :      # ST-Link/V2 programming adapter\n\n    # ST-Link V1, if using a STM8S discovery board\n    # important: It needs a special entry in /etc/modprobe.d\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3744\", MODE=\"0666\", GROUP=\"plugdev\"\n\n    # ST-Link/V2, the china adapter with the green plastic housing\n    ATTR{idVendor}==\"0483\", ATTR{idProduct}==\"3748\", MODE=\"0666\", GROUP=\"plugdev\"  Finally, it is time to (re-) connect the board. Now dmesg should show that\nthe mass storage device of the Discovery board is ignored:      [  815.228928] usbcore: deregistering interface driver uas\n    [  815.229201] usbcore: deregistering interface driver usb-storage\n    [  823.001086] usb 1-3: new full-speed USB device number 7 using xhci_hcd\n    [  823.374719] usb 1-3: New USB device found, idVendor=0483, idProduct=3744\n    [  823.374724] usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n    [  823.374726] usb 1-3: Product: STM32 STLink\n    [  823.374728] usb 1-3: Manufacturer: STMicroelectronics\n    [  823.374730] usb 1-3: SerialNumber: W\\xffffffc3\\xffffffbf\\xffffffbfp\\x06reWW7\\x18\\x12g\n    [  823.746878] usb-storage 1-3:1.0: USB Mass Storage device detected\n    [  823.748299] usb-storage 1-3:1.0: device ignored\n    [  823.748453] usbcore: registered new interface driver usb-storage\n    [  823.771094] usbcore: registered new interface driver uas  Let's read the preinstalled firmware of the STM8S105:      stm8flash -cstlink \"-pstm8s105?6\" -r flash.img",
            "title": "Usage with Linux and stm8flash"
        },
        {
            "location": "/hardware/stm8sdiscovery/#further-reading",
            "text": "AN3332 :\nGenerating PWM signals using STM8S-DISCOVERY   AN3259 :\nRS232 communications with a terminal using the STM8S-DISCOVERY",
            "title": "Further reading"
        },
        {
            "location": "/developer/macro/",
            "text": "Preprocessor macros to disguise plain C as C++\n\n\nPorting some Arduino-like functions to C is not too difficult. The challenge\nis to keep the syntax differences to the real C++-based Arduino system as\nsmall a possible while still using plain C.\n\n\nThere are subtle differences in the API concepts of the Arduino libraries.\nUnfortunatly, they all require different strategies to mimic a C++ user API.\nThe basic criteria are:\n\n\n\n\n\n\nmulti-instance or single-instance\n\n\n\n\n\n\nis a constructor call mandatory or not (typically the \nbegin()\n-method)\n\n\n\n\n\n\nAdditionally, there are some more detailed destinctions:\n\n\n\n\n\n\npolymorph instantiation declaration or simple declaration\n\n\n\n\n\n\ngeneral single instance library or pre-instantiated single instance\n  library\n\n\n\n\n\n\ninheritance via virtual methods (most output-type libraries inherit from\n  the Print class)\n\n\n\n\n\n\nAs a result, there are several different cases to consider:\n\n\nSingle-instance, pre-instantiated, with constructor\n\n\nThe data is kept locally within the class module. There is no\n  instantiation declaration. No instance references need to be passed to any\n  any function calls. All initialization is done by the constructor\n  function.\n\n\nThis is the easiest and most straight-forward case. No help from the\n  preprocessor is required. It is sufficient to choose the function names to\n  match the original class::method names. Polymorph methods are represented\n  by a set of name-mangled functions.\n\n\nThe behaviour of this construction is very similar to a real C++ class.\n\n\nExamples:\n\n\nSPI\n, \nI2C\n,\n\nHardwareSerial\n \n\n\n#include <I2C.h>\n\nsetup() {\n    I2c_begin();\n    I2c_write(0x1e, 0x02,0x00);\n}\n\n\n\n\n\nRequired preprocessor help\n\n\n\n\nnone\n\n\n\n\nSingle-instance, with constructor\n\n\nThe data is kept locally within the class module. The instantiation\n  declaration defines the one instance name to be used. It might pass some\n  configuration data which is remembered for later use. As there is always\n  exactly one instance, no instance references need to be remembered and\n  passed to any function calls. The instance name is more a cosmetic issue.\n\n\nThe constructor does the actual configuration and initialization. It might\n  use the configuration data given earlier with the instantiation\n  declaration.\n\n\nThe behaviour of this construction is very similar to a real C++ class.\n\n\nPolymorph instantiation declarations are possible.\n  Non-constant values for the initialization are supported.\n\n\nExamples:\n \nLiquidCrystal\n\n\nint rs_pin = 2;\n\nLiquidCrystal (lcd, rs_pin,3,4, 5,6,7,8);\n\nsetup() {\n    lcd_begin(16,2);\n    lcd_setCursor(0,1);\n    lcd_print_s(\"Hello, world!\");\n}\n\n\n\n\nRequired preprocessor help\n\n\n\n\npolymorph instantiation\n\n\nremember configuration data for later use with the constructor\n\n\nsetting up alias definitions to include the instance name in the function\n  names.\n\n\n\n\nMulti-instance class, with constructor\n\n\nThe data can be kept locally within the class module. The constructor\n  allocates and initializes the required data structure and does required\n  I/O-initializations. It returns a reference item to identify the instance.\n  This reference item is typically a pointer to the instance structure or\n  and index number to an internal table. It is passed to any following\n  method call.\n\n\nThe behaviour of this construction is very similar to a real C++ class.\n  The main pitfall is the missing automatic destructor call. Luckily, this\n  C++ feature is rarely used, anyway.\n\n\nPolymorph instantiation declarations are possible.\n\n\nExamples: \nServo\n\n\n#include <Servo.h>\n\nServo(servo1);\nServo(servo2);\n\nsetup() {\n    servo1_attach(5);\n    servo2_attach(6);\n}\n\nloop() {\n    servo1_write(90);\n    servo2_write(150);\n}\n\n\n\n\nRequired preprocessor help\n\n\n\n\npolymorph instantiation\n\n\nremember configuration data for later use with the constructor\n\n\nsave the instance reference item on initialization\n\n\nsetting up alias definitions to \n\n\ninclude the instance name in the function names and\n\n\ninclude the instance reference item with the parameter list of every function call.\n\n\n\n\nMulti-instance class, no constructor\n\n\nAs there is no strictly defined first function call which could allocate\n  and initialize internal data structures, the data has to be kept in a data\n  structure in the user area. A pointer to this data structure is passed to\n  any following method call.\n\n\nThis case can be difficult. As there is no dedicated constructor call, the\n  library has to keep track if the current instance has been initialized\n  already and has to do so if not. That means, that the needed I/O resources\n  can't be initialized before the first function call. That might be a\n  problem for some applications as I/O pins might stay in a floating input\n  state for quite some time.\n\n\nSecond drawback of this concept is the fact, that the instance data\n  initialization values have to be known at compile time and can't be\n  variables or the result of function calls at run time, e.g. from a\n  configuration space in EEPROM.\n\n\nTo solve these two problems it might be necessary to introduce an\n  additional constructor-type function, that can be called from the setup()\n  function or for any needed reconfiguration. Since the instance data is in\n  the user space anyway, it could be modified there directly. But this would\n  be an even worse violation of all modularization concepts and should be\n  avoided.\n\n\nPolymorph instantiation declarations are possible.\n\n\nExamples: \nStepper\n\n\nBy requiring the user to add a call to the added constructor as the\n  mandatory first call to the instance it could be treated as any other\n  multi-instance class with constructor, see above. The resulting API is not\n  identical to Arduino anymore, but still very similar.\n\n\n#include <Stepper.h>\n\nStepper (StepperA, 100, 6, 7);\nStepper (StepperB, 200, 8, 9, 10, 11);\n\nvoid setup() {\n  StepperA_setSpeed(60);\n  StepperB_setSpeed(60);\n}\n\nvoid loop() {\n  StepperA_step(20);\n  StepperB_step(40);\n}\n\n\n\n\nRequired preprocessor help\n\n\n\n\npolymorph instantiation.\n\n\nconvert the instantiation declaration into an instance data item declaration\n  and initialization.\n\n\nsetting up alias definitions to \n\n\ninclude the instance name in the function names and\n\n\ninclude a pointer to the instance data item with the parameter list of\n    every function call.\n\n\n\n\nInheritance\n\n\nMost output-type libraries inherit the methods from class Print by providing\na matching write() method. This works by providing all print functions a\nfunction pointer to the write function, that should be used.\n\n\nRequired preprocessor help\n\n\n\n\nsetting up alias definitions to \n\n\ninclude the instance name of the output module in the function names of\n    the print functions and\n\n\ninclude a pointer to the output write function with the parameter list of\n    every (aliased) print function call.",
            "title": "C preprocessor macro magic"
        },
        {
            "location": "/developer/macro/#preprocessor-macros-to-disguise-plain-c-as-c",
            "text": "Porting some Arduino-like functions to C is not too difficult. The challenge\nis to keep the syntax differences to the real C++-based Arduino system as\nsmall a possible while still using plain C.  There are subtle differences in the API concepts of the Arduino libraries.\nUnfortunatly, they all require different strategies to mimic a C++ user API.\nThe basic criteria are:    multi-instance or single-instance    is a constructor call mandatory or not (typically the  begin() -method)    Additionally, there are some more detailed destinctions:    polymorph instantiation declaration or simple declaration    general single instance library or pre-instantiated single instance\n  library    inheritance via virtual methods (most output-type libraries inherit from\n  the Print class)    As a result, there are several different cases to consider:",
            "title": "Preprocessor macros to disguise plain C as C++"
        },
        {
            "location": "/developer/macro/#single-instance-pre-instantiated-with-constructor",
            "text": "The data is kept locally within the class module. There is no\n  instantiation declaration. No instance references need to be passed to any\n  any function calls. All initialization is done by the constructor\n  function.  This is the easiest and most straight-forward case. No help from the\n  preprocessor is required. It is sufficient to choose the function names to\n  match the original class::method names. Polymorph methods are represented\n  by a set of name-mangled functions.  The behaviour of this construction is very similar to a real C++ class.  Examples:  SPI ,  I2C , HardwareSerial    #include <I2C.h>\n\nsetup() {\n    I2c_begin();\n    I2c_write(0x1e, 0x02,0x00);\n}  Required preprocessor help   none",
            "title": "Single-instance, pre-instantiated, with constructor"
        },
        {
            "location": "/developer/macro/#single-instance-with-constructor",
            "text": "The data is kept locally within the class module. The instantiation\n  declaration defines the one instance name to be used. It might pass some\n  configuration data which is remembered for later use. As there is always\n  exactly one instance, no instance references need to be remembered and\n  passed to any function calls. The instance name is more a cosmetic issue.  The constructor does the actual configuration and initialization. It might\n  use the configuration data given earlier with the instantiation\n  declaration.  The behaviour of this construction is very similar to a real C++ class.  Polymorph instantiation declarations are possible.\n  Non-constant values for the initialization are supported.  Examples:   LiquidCrystal  int rs_pin = 2;\n\nLiquidCrystal (lcd, rs_pin,3,4, 5,6,7,8);\n\nsetup() {\n    lcd_begin(16,2);\n    lcd_setCursor(0,1);\n    lcd_print_s(\"Hello, world!\");\n}  Required preprocessor help   polymorph instantiation  remember configuration data for later use with the constructor  setting up alias definitions to include the instance name in the function\n  names.",
            "title": "Single-instance, with constructor"
        },
        {
            "location": "/developer/macro/#multi-instance-class-with-constructor",
            "text": "The data can be kept locally within the class module. The constructor\n  allocates and initializes the required data structure and does required\n  I/O-initializations. It returns a reference item to identify the instance.\n  This reference item is typically a pointer to the instance structure or\n  and index number to an internal table. It is passed to any following\n  method call.  The behaviour of this construction is very similar to a real C++ class.\n  The main pitfall is the missing automatic destructor call. Luckily, this\n  C++ feature is rarely used, anyway.  Polymorph instantiation declarations are possible.  Examples:  Servo  #include <Servo.h>\n\nServo(servo1);\nServo(servo2);\n\nsetup() {\n    servo1_attach(5);\n    servo2_attach(6);\n}\n\nloop() {\n    servo1_write(90);\n    servo2_write(150);\n}  Required preprocessor help   polymorph instantiation  remember configuration data for later use with the constructor  save the instance reference item on initialization  setting up alias definitions to   include the instance name in the function names and  include the instance reference item with the parameter list of every function call.",
            "title": "Multi-instance class, with constructor"
        },
        {
            "location": "/developer/macro/#multi-instance-class-no-constructor",
            "text": "As there is no strictly defined first function call which could allocate\n  and initialize internal data structures, the data has to be kept in a data\n  structure in the user area. A pointer to this data structure is passed to\n  any following method call.  This case can be difficult. As there is no dedicated constructor call, the\n  library has to keep track if the current instance has been initialized\n  already and has to do so if not. That means, that the needed I/O resources\n  can't be initialized before the first function call. That might be a\n  problem for some applications as I/O pins might stay in a floating input\n  state for quite some time.  Second drawback of this concept is the fact, that the instance data\n  initialization values have to be known at compile time and can't be\n  variables or the result of function calls at run time, e.g. from a\n  configuration space in EEPROM.  To solve these two problems it might be necessary to introduce an\n  additional constructor-type function, that can be called from the setup()\n  function or for any needed reconfiguration. Since the instance data is in\n  the user space anyway, it could be modified there directly. But this would\n  be an even worse violation of all modularization concepts and should be\n  avoided.  Polymorph instantiation declarations are possible.  Examples:  Stepper  By requiring the user to add a call to the added constructor as the\n  mandatory first call to the instance it could be treated as any other\n  multi-instance class with constructor, see above. The resulting API is not\n  identical to Arduino anymore, but still very similar.  #include <Stepper.h>\n\nStepper (StepperA, 100, 6, 7);\nStepper (StepperB, 200, 8, 9, 10, 11);\n\nvoid setup() {\n  StepperA_setSpeed(60);\n  StepperB_setSpeed(60);\n}\n\nvoid loop() {\n  StepperA_step(20);\n  StepperB_step(40);\n}  Required preprocessor help   polymorph instantiation.  convert the instantiation declaration into an instance data item declaration\n  and initialization.  setting up alias definitions to   include the instance name in the function names and  include a pointer to the instance data item with the parameter list of\n    every function call.",
            "title": "Multi-instance class, no constructor"
        },
        {
            "location": "/developer/macro/#inheritance",
            "text": "Most output-type libraries inherit the methods from class Print by providing\na matching write() method. This works by providing all print functions a\nfunction pointer to the write function, that should be used.  Required preprocessor help   setting up alias definitions to   include the instance name of the output module in the function names of\n    the print functions and  include a pointer to the output write function with the parameter list of\n    every (aliased) print function call.",
            "title": "Inheritance"
        },
        {
            "location": "/developer/pin_mapping/",
            "text": "Pin mapping scheme\n\n\nMany Arduino sketches and libraries contain hard-coded assumptions about the\nnumber of pins with special functions. Ideally, all these numbers would be\nthe same and all programs could be compiled without changes. This is not\npossible, but let's check how close we could get for the STM8S103F.\n\n\nPossible logical pin number mappings\n\n\nFunctional mapping\n would try to match the pins with special functions\n(like serial, SPI, I2C, analog input and PWM output) as closely as possible.\n\n\nGeometrical mapping\n would choose a logical order of the CPU pins as they\nare accessible on the CPU or with a breakout board.\n\n\nFunctional mapping would allow for designing a PCB using the Arduino Uno\nform factor and take advantage of all the existing shields (as long as they\nare 3.3V compatible). The number of needed changes to existing sketches\nwould be cut down to a minimum. The downside would be a pretty random order\nof pin numbers when using a simple breakout board.\n\n\nGeometrical mapping is easier for breadboard use, but will always require\nchanges on existing sketches. Since we need to modify them from C++ to C\nsyntax anyway that is maybe a less severe problem than it sounds.\n\n\na) Matching the communication pins\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\nPD6\n\n\nRX\n\n\nAin6\n\n\n0\n\n\nPD0\n\n\n\n\n\n\n\n\nPD5\n\n\nTX\n\n\nAin5\n\n\n1\n\n\nPD1\n\n\n\n\n\n\n\n\nPA3\n\n\nSS\n\n\n\n\n10\n\n\nPB2\n\n\nPWM\n\n\n\n\n\n\nPC6\n\n\nMOSI\n\n\n\n\n11\n\n\nPB3\n\n\nPWM\n\n\n\n\n\n\nPC7\n\n\nMISO\n\n\n\n\n12\n\n\nPB4\n\n\n\n\n\n\n\n\nPC5\n\n\nSCK\n\n\n\n\n13\n\n\nPB5\n\n\nLED\n\n\n\n\n\n\nPB5\n\n\nSDA\n\n\nLED\n\n\n18\n\n\nPC4\n\n\nAin4\n\n\n\n\n\n\nPB4\n\n\nSCL\n\n\n\n\n19\n\n\nPC5\n\n\nAin5\n\n\n\n\n\n\n\n\nb) Matching the analog inputs\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\nC4\n\n\nAin2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD2\n\n\nAin3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD3\n\n\nAin4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nD5\n\n\nAin5\n\n\nTX\n\n\n\n\n\n\n\n\n\n\n\n\nD6\n\n\nAin6\n\n\nRX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nc) Matching the PWM-capable pins\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9\n\n\n\n\n\n\n\n\n\n\n(\n\n\n\n\n\n\n10\n\n\n)\n\n\n\n\n\n\n\n\n(\n\n\n\n\n\n\n11\n\n\n)\n\n\n\n\n\n\n\n\n\n\nd) Matching the LED: (collision)\n\n\n\n\n\n\n\n\nSTM8 pin\n\n\nName\n\n\nAlt\n\n\nArduino pin\n\n\nATmega pin\n\n\nAlt\n\n\n\n\n\n\n\n\n\n\nPB5\n\n\nSDA\n\n\n\n\n13\n\n\nSCK\n\n\n\n\n\n\n\n\n\n\ne) Simple geometric numbering for SO20 package (count up from 1, starting at pin 1)\n\n\n 1-3  -> PD4-PD6\n 4-6  -> PA1-PA3\n 7-8  -> PB5-PB4 (reverse order)\n 9-13 -> PC3-PC7\n14-16 -> PD1-PD3\n\n\n\nSPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone)\n\nI2C: 7,8\n\nserial: 2,3\n\nAnalog: 2,3,10,15,16 (data sheet order would be: 10,15,16,2,3)  \n\n\n\n\nEasy and logical for use on a breadboard\n\n\nLogical port pin ordering\n\n\nAnalog pins are scattered\n\n\nAll functions use totally different pin numbers than Arduino\n\n\n\n\nf) Simple geometric numbering for square UFQFPN20 package (count up from 0, starting at pin 2/PA1)\n\n\n 0-2  -> PA1-PA3\n 3-4  -> PB5-PB4 (reverse order)\n 5-9 -> PC3-PC7\n10-15 -> PD1-PD6\n\n\n\nserial: 14,15\n\nSPI: 2,7,8,9\n\nI2C: 3,4\n\nAnalog: 6,11,12,14,15 (for an easier structure maybe use non-continous\nnumbers for the Arduino-like Ax-numbers: A0, A1, A2, A4, A5)\n\nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping)\n\nPWM Bitmap pin 15-0: 0011 0000 0110 0100 = 0x3064 (regular mapping)\n\nPWM Bitmap pin 15-0: 0001 0011 1110 0100 = 0x13e4 (alternate mapping)  \n\n\n\n\nEasy and logical for use on a breadboard\n\n\nVery clear and logical port pin ordering\n\n\nAnalog pins are still scattered around\n\n\nTX and RX would be the rarely used analog pin numbers A3/A4 or A4/A5 at\n   the end of the analog pin number list\n\n\nAt least the analog pins are in data sheet order\n\n\nAll functions use totally different pin numbers than Arduino\n\n\n\n\nComparing the results\n\n\nCompare logical/functional mapping vs. simple geometrical numbering\n\n\n\n\n\n\n\n\nPhys. STM8 pin\n\n\nName\n\n\nFunctions\n\n\nFunctional mapping\n\n\nGeometrical\n\n\nmapping\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstrict\n\n\nfrom PA1\n\n\n\n\n\n\n1\n\n\nPD4\n\n\nUART_CLK/T2-1/beep\n\n\n5\n\n\n1~\n\n\n13~\n\n\n\n\n\n\n2\n\n\nPD5\n\n\nTX/Ain5\n\n\n\n\n1\n\n\n2  14/A3\n\n\n\n\n\n\n3\n\n\nPD6\n\n\nRX/Ain6\n\n\n\n\n0\n\n\n3  15/A4\n\n\n\n\n\n\n5\n\n\nPA1\n\n\n(OscIn, kein HS)\n\n\n6\n\n\n4\n\n\n0\n\n\n\n\n\n\n6\n\n\nPA2\n\n\n(OscIn, kein HS)\n\n\n7\n\n\n5\n\n\n1\n\n\n\n\n\n\n10\n\n\nPA3\n\n\nSS/T2-3\n\n\n\n\n10\n\n\n6~ 2~\n\n\n\n\n\n\n11\n\n\nPB5\n\n\nSDA    LED\n\n\n18\n\n\n7\n\n\n3\n\n\n\n\n\n\n12\n\n\nPB4\n\n\nSCL\n\n\n19\n\n\n8\n\n\n4\n\n\n\n\n\n\n13\n\n\nPC3\n\n\nT1-3/[T1-n1]\n\n\n9\n\n\n9~\n\n\n5~(n~)\n\n\n\n\n\n\n14\n\n\nPC4\n\n\nT1-4/Ain2/[T1-n2]\n\n\n4\n\n\n10~\n\n\n6~(n~)/A0\n\n\n\n\n\n\n15\n\n\nPC5\n\n\nSCK/[T2-1]\n\n\n13\n\n\n11~\n\n\n7(~)\n\n\n\n\n\n\n16\n\n\nPC6\n\n\nMOSI/[T1-1]\n\n\n11\n\n\n12~\n\n\n8(~)\n\n\n\n\n\n\n17\n\n\nPC7\n\n\nMISO/[T1-2]\n\n\n12\n\n\n13~\n\n\n9(~)\n\n\n\n\n\n\n18\n\n\nPD1\n\n\n(SWIM)\n\n\n8\n\n\n14\n\n\n10\n\n\n\n\n\n\n19\n\n\nPD2\n\n\nAin3/[T2-3]\n\n\n3\n\n\n15(~)\n\n\n11(~~)/A1\n\n\n\n\n\n\n20\n\n\nPD3\n\n\nAin4/T2-2\n\n\n2\n\n\n16~\n\n\n12~/A2\n\n\n\n\n\n\n\n\nFunctional pin mapping:\n\n\nTX/RX,SPI,I2C match the Arduino numbers\n\n\nAnalog mapped to D0-D4 (instead of D14-D19),\n\n\nPWM 2,3,4,5,9,10,11,12,13 (Arduino PWM: 3,5,6,9,10,11, all matched except\nfor pin 6)\n\n\nnon-existant: 14-17 -> it might be better to map I2C to 14 and 15.\n\n\nStrict geometrical pin mapping:\n\n\nSPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone)\n\nI2C: 7,8\n\nserial: 2,3\n\nanalog: 2,3,10,15,16\n\nPWM regular: 2,12,13\n\nPWM alternate: 7,8,9\n\nPWM alternate negative: 5,6\n\nPWM alternate (duplicates): 11  \n\n\nPin remapping\n\n\nSome functions share the same CPU port pin. The Alternate function remapping\nregister (AFR) is used to choose the actual function. Most important choice\nis for pin PC5-PC7: SPI (default) or PWM (alternate). Unfortunatly, this\ninfluences PD4 as well (default PWM, alternate non-PWM).\n\n\nThe AFR is two EEPROM cells at 0x4803 (OPT2) and 0x4804 (NOPT2, inverted).\nProgrammable via SWIM (see UM0470) and in IAP-Mode (see PM0051).\n\n\n\n\n\n\n\n\nBit\n\n\nPin influenced\n\n\nFunction for 0\n\n\nFunction for 1\n\n\n\n\n\n\n\n\n\n\nAFR7\n\n\nPC3,PC4\n\n\ndefault\n\n\nTIM1_CH1N, TIM1_CH2N\n\n\n\n\n\n\nAFR4\n\n\nPB4,PB5\n\n\ndefault\n\n\nADC_ETR, TIM1_BKIN\n\n\n\n\n\n\nAFR3\n\n\nPC3\n\n\ndefault\n\n\nTLI\n\n\n\n\n\n\nAFR1\n\n\nPA3,PD2\n\n\ndefault\n\n\nSPI_NSS, TIM2_CH3\n\n\n\n\n\n\nAFR0\n\n\nPC5-PC7\n\n\nGPIO/SPI\n\n\nTIM2_CH1, TIM1_CH1, TIM1_CH2",
            "title": "Ways to define a pin mapping"
        },
        {
            "location": "/developer/pin_mapping/#pin-mapping-scheme",
            "text": "Many Arduino sketches and libraries contain hard-coded assumptions about the\nnumber of pins with special functions. Ideally, all these numbers would be\nthe same and all programs could be compiled without changes. This is not\npossible, but let's check how close we could get for the STM8S103F.",
            "title": "Pin mapping scheme"
        },
        {
            "location": "/developer/pin_mapping/#possible-logical-pin-number-mappings",
            "text": "Functional mapping  would try to match the pins with special functions\n(like serial, SPI, I2C, analog input and PWM output) as closely as possible.  Geometrical mapping  would choose a logical order of the CPU pins as they\nare accessible on the CPU or with a breakout board.  Functional mapping would allow for designing a PCB using the Arduino Uno\nform factor and take advantage of all the existing shields (as long as they\nare 3.3V compatible). The number of needed changes to existing sketches\nwould be cut down to a minimum. The downside would be a pretty random order\nof pin numbers when using a simple breakout board.  Geometrical mapping is easier for breadboard use, but will always require\nchanges on existing sketches. Since we need to modify them from C++ to C\nsyntax anyway that is maybe a less severe problem than it sounds.  a) Matching the communication pins     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt      PD6  RX  Ain6  0  PD0     PD5  TX  Ain5  1  PD1     PA3  SS   10  PB2  PWM    PC6  MOSI   11  PB3  PWM    PC7  MISO   12  PB4     PC5  SCK   13  PB5  LED    PB5  SDA  LED  18  PC4  Ain4    PB4  SCL   19  PC5  Ain5     b) Matching the analog inputs     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt      C4  Ain2        D2  Ain3        D3  Ain4        D5  Ain5  TX       D6  Ain6  RX        c) Matching the PWM-capable pins     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt         3         5         6         9      (    10  )     (    11  )      d) Matching the LED: (collision)     STM8 pin  Name  Alt  Arduino pin  ATmega pin  Alt      PB5  SDA   13  SCK      e) Simple geometric numbering for SO20 package (count up from 1, starting at pin 1)   1-3  -> PD4-PD6\n 4-6  -> PA1-PA3\n 7-8  -> PB5-PB4 (reverse order)\n 9-13 -> PC3-PC7\n14-16 -> PD1-PD3  SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone) \nI2C: 7,8 \nserial: 2,3 \nAnalog: 2,3,10,15,16 (data sheet order would be: 10,15,16,2,3)     Easy and logical for use on a breadboard  Logical port pin ordering  Analog pins are scattered  All functions use totally different pin numbers than Arduino   f) Simple geometric numbering for square UFQFPN20 package (count up from 0, starting at pin 2/PA1)   0-2  -> PA1-PA3\n 3-4  -> PB5-PB4 (reverse order)\n 5-9 -> PC3-PC7\n10-15 -> PD1-PD6  serial: 14,15 \nSPI: 2,7,8,9 \nI2C: 3,4 \nAnalog: 6,11,12,14,15 (for an easier structure maybe use non-continous\nnumbers for the Arduino-like Ax-numbers: A0, A1, A2, A4, A5) \nPWM: 2,5,6,12 plus either only 13 or 7-9 but not 13 (via alternate mapping) \nPWM Bitmap pin 15-0: 0011 0000 0110 0100 = 0x3064 (regular mapping) \nPWM Bitmap pin 15-0: 0001 0011 1110 0100 = 0x13e4 (alternate mapping)     Easy and logical for use on a breadboard  Very clear and logical port pin ordering  Analog pins are still scattered around  TX and RX would be the rarely used analog pin numbers A3/A4 or A4/A5 at\n   the end of the analog pin number list  At least the analog pins are in data sheet order  All functions use totally different pin numbers than Arduino",
            "title": "Possible logical pin number mappings"
        },
        {
            "location": "/developer/pin_mapping/#comparing-the-results",
            "text": "Compare logical/functional mapping vs. simple geometrical numbering     Phys. STM8 pin  Name  Functions  Functional mapping  Geometrical  mapping          strict  from PA1    1  PD4  UART_CLK/T2-1/beep  5  1~  13~    2  PD5  TX/Ain5   1  2  14/A3    3  PD6  RX/Ain6   0  3  15/A4    5  PA1  (OscIn, kein HS)  6  4  0    6  PA2  (OscIn, kein HS)  7  5  1    10  PA3  SS/T2-3   10  6~ 2~    11  PB5  SDA    LED  18  7  3    12  PB4  SCL  19  8  4    13  PC3  T1-3/[T1-n1]  9  9~  5~(n~)    14  PC4  T1-4/Ain2/[T1-n2]  4  10~  6~(n~)/A0    15  PC5  SCK/[T2-1]  13  11~  7(~)    16  PC6  MOSI/[T1-1]  11  12~  8(~)    17  PC7  MISO/[T1-2]  12  13~  9(~)    18  PD1  (SWIM)  8  14  10    19  PD2  Ain3/[T2-3]  3  15(~)  11(~~)/A1    20  PD3  Ain4/T2-2  2  16~  12~/A2     Functional pin mapping:  TX/RX,SPI,I2C match the Arduino numbers  Analog mapped to D0-D4 (instead of D14-D19),  PWM 2,3,4,5,9,10,11,12,13 (Arduino PWM: 3,5,6,9,10,11, all matched except\nfor pin 6)  non-existant: 14-17 -> it might be better to map I2C to 14 and 15.  Strict geometrical pin mapping:  SPI: 6,11,12,13 (same numbers as Arduino, but with different meanings ->\nerror prone) \nI2C: 7,8 \nserial: 2,3 \nanalog: 2,3,10,15,16 \nPWM regular: 2,12,13 \nPWM alternate: 7,8,9 \nPWM alternate negative: 5,6 \nPWM alternate (duplicates): 11",
            "title": "Comparing the results"
        },
        {
            "location": "/developer/pin_mapping/#pin-remapping",
            "text": "Some functions share the same CPU port pin. The Alternate function remapping\nregister (AFR) is used to choose the actual function. Most important choice\nis for pin PC5-PC7: SPI (default) or PWM (alternate). Unfortunatly, this\ninfluences PD4 as well (default PWM, alternate non-PWM).  The AFR is two EEPROM cells at 0x4803 (OPT2) and 0x4804 (NOPT2, inverted).\nProgrammable via SWIM (see UM0470) and in IAP-Mode (see PM0051).     Bit  Pin influenced  Function for 0  Function for 1      AFR7  PC3,PC4  default  TIM1_CH1N, TIM1_CH2N    AFR4  PB4,PB5  default  ADC_ETR, TIM1_BKIN    AFR3  PC3  default  TLI    AFR1  PA3,PD2  default  SPI_NSS, TIM2_CH3    AFR0  PC5-PC7  GPIO/SPI  TIM2_CH1, TIM1_CH1, TIM1_CH2",
            "title": "Pin remapping"
        },
        {
            "location": "/developer/sdcc/",
            "text": "Compiler\n\n\nTutorials:\nhttp://www.cnx-software.com/2015/04/13/how-to-program-stm8s-1-board-in-linux/\n\n\nSTM8-Support only started with Version 3.4 in Ubuntu 14.10. For Ubuntu 14.4:\n\n\n    add-apt-repository ppa:laczik/ppa\n    apt-get update\n    apt-get install sdcc\n\n\n\n\nBut even this version is fairly old and contains some known bugs. Better\ndownload a current snapshot build from http://sdcc.sourceforge.net/ and\nunpack it to \n/opt/sdcc\n. This requires a current version of libstdc++6:\n\n\n    add-apt-repository ppa:ubuntu-toolchain-r/test\n    apt-get update\n    apt-get install libstdc++6\n\n\n\n\nIf you prefer to compile stm8flash yourself instead of using the Linux\nbinaries in the \ntools\n directory:\n\n\n    git clone https://github.com/vdudouyt/stm8flash.git\n    cd stm8flash\n    make\n    sudo make install\n\n\n\n\nDownload some example code:\n\n\n    git clone https://github.com/vdudouyt/sdcc-examples-stm8.git\n    cd sdcc-examples-stm8\n\n\n\n\nThe examples are meant for the STM8L, not the STM8S. This requires some\nchanges to account for the different pinout and register addresses (see below).\nFinally upload the binary to the CPU:\n\n\n    stm8flash -c stlinkv2 -p stm8s103?3 -w blinky.ihx\n\n\n\n\nMixing assembler code with C code\n\n\nc-code:\n\n\nstacktest(0x1234, 0x5678);\n\n\n\nassember:\n\n\npush    #0x78\npush    #0x56\npush    #0x34\npush    #0x12\ncall    _stacktest\n\n\n\nresulting stack content (starting at [SP], using simulator sstm8):\n\n\n0> dch 0x17f9\n0x017f9 c0 80 ab 12 34 56 78 5b ....4Vx[\n\n\n\n=> first paramter starts at [SP+3], MSB first.\n\n\nRegister assignment\n\n\nreturn values\n:\n8 bit values in A, 16 bit values in X, 32 bit values in Y/X (Y=MSB, X=LSB)\n\n\nregister preservation\n:\nNot implemented for the STM8 (yet?). For some architectures SDCC implements\nthe possibility to mark a function that it does not effect the contents of\nsome registers:\n\n\nvoid f(void) __preserves_regs(b, c, iyl, iyh);\n\n\n\nNotes on SDCC\n\n\nThe linker \nsdld\n does not automatically link the object file for main.c if it\nis part of a library. It must be part of the list of object files. (Important\nfor the build process with Arduino.mk)\n\n\nBefehl \n__critical{..}\n sollte eigentlich den vorherigen Interrupt-Zustand\nwiederherstellen, es wird aber einfach ein festes Paar sim/rim produziert.\nMit \"push cc; sim\" und \"pop cc\" klappt es im Simulator, aber nicht in der\nRealit\u00e4t.\n\n\nF\u00fcr jeden benutzten Interrupt \nmuss\n ein Prototyp in der Datei stehen, in\nder auch main() definiert ist. Aber f\u00fcr jeden Prototypen, f\u00fcr den es keine\nFunktion gibt, ergibt einen Linkerfehler. Das erkl\u00e4rt den Sinn von stm8s_it.h\nim Projektverzeichniss. Eine Arduino-\u00e4hnliche Umgebung muss diese Datei also\nnach Analyse aller Sourcen selber erzeugen.\n\n\nSimulator sstm8\n\n\nHas improved a lot recently. The UART and timer part is usable now (as of\nrev. 9998) and the subtle differences in the memory layout of the I/O section\nfor the different cpu subtypes are factored in.\n\n\nMake sure to use a recent snapshot build if you are planing to use simulator!\n\n\nMissing peephole optimisations\n\n\nSee discussion of \nissue #14\n\n\nMissing compiler features\n\n\n\n\n_ _preserves_regs() function attribute not supported\n\n\n_ \nattribute\n _((weak))\n\n\n_ _critical{} generates sim/rim instead of push cc,sim/pop cc\n\n\ndead code elimination: Does not recognize tables of const values. Using a\n  const table would still pull in the whole object file, even when all\n  accesses to the table have been eleminated by the optimizer. Only way out\n  is to use \n#define\n statements instead.",
            "title": "Using the SDCC compiler"
        },
        {
            "location": "/developer/sdcc/#compiler",
            "text": "Tutorials:\nhttp://www.cnx-software.com/2015/04/13/how-to-program-stm8s-1-board-in-linux/  STM8-Support only started with Version 3.4 in Ubuntu 14.10. For Ubuntu 14.4:      add-apt-repository ppa:laczik/ppa\n    apt-get update\n    apt-get install sdcc  But even this version is fairly old and contains some known bugs. Better\ndownload a current snapshot build from http://sdcc.sourceforge.net/ and\nunpack it to  /opt/sdcc . This requires a current version of libstdc++6:      add-apt-repository ppa:ubuntu-toolchain-r/test\n    apt-get update\n    apt-get install libstdc++6  If you prefer to compile stm8flash yourself instead of using the Linux\nbinaries in the  tools  directory:      git clone https://github.com/vdudouyt/stm8flash.git\n    cd stm8flash\n    make\n    sudo make install  Download some example code:      git clone https://github.com/vdudouyt/sdcc-examples-stm8.git\n    cd sdcc-examples-stm8  The examples are meant for the STM8L, not the STM8S. This requires some\nchanges to account for the different pinout and register addresses (see below).\nFinally upload the binary to the CPU:      stm8flash -c stlinkv2 -p stm8s103?3 -w blinky.ihx  Mixing assembler code with C code  c-code:  stacktest(0x1234, 0x5678);  assember:  push    #0x78\npush    #0x56\npush    #0x34\npush    #0x12\ncall    _stacktest  resulting stack content (starting at [SP], using simulator sstm8):  0> dch 0x17f9\n0x017f9 c0 80 ab 12 34 56 78 5b ....4Vx[  => first paramter starts at [SP+3], MSB first.  Register assignment  return values :\n8 bit values in A, 16 bit values in X, 32 bit values in Y/X (Y=MSB, X=LSB)  register preservation :\nNot implemented for the STM8 (yet?). For some architectures SDCC implements\nthe possibility to mark a function that it does not effect the contents of\nsome registers:  void f(void) __preserves_regs(b, c, iyl, iyh);  Notes on SDCC  The linker  sdld  does not automatically link the object file for main.c if it\nis part of a library. It must be part of the list of object files. (Important\nfor the build process with Arduino.mk)  Befehl  __critical{..}  sollte eigentlich den vorherigen Interrupt-Zustand\nwiederherstellen, es wird aber einfach ein festes Paar sim/rim produziert.\nMit \"push cc; sim\" und \"pop cc\" klappt es im Simulator, aber nicht in der\nRealit\u00e4t.  F\u00fcr jeden benutzten Interrupt  muss  ein Prototyp in der Datei stehen, in\nder auch main() definiert ist. Aber f\u00fcr jeden Prototypen, f\u00fcr den es keine\nFunktion gibt, ergibt einen Linkerfehler. Das erkl\u00e4rt den Sinn von stm8s_it.h\nim Projektverzeichniss. Eine Arduino-\u00e4hnliche Umgebung muss diese Datei also\nnach Analyse aller Sourcen selber erzeugen.  Simulator sstm8  Has improved a lot recently. The UART and timer part is usable now (as of\nrev. 9998) and the subtle differences in the memory layout of the I/O section\nfor the different cpu subtypes are factored in.  Make sure to use a recent snapshot build if you are planing to use simulator!  Missing peephole optimisations  See discussion of  issue #14  Missing compiler features   _ _preserves_regs() function attribute not supported  _  attribute  _((weak))  _ _critical{} generates sim/rim instead of push cc,sim/pop cc  dead code elimination: Does not recognize tables of const values. Using a\n  const table would still pull in the whole object file, even when all\n  accesses to the table have been eleminated by the optimizer. Only way out\n  is to use  #define  statements instead.",
            "title": "Compiler"
        },
        {
            "location": "/developer/spl/",
            "text": "ST Standard Peripherie Library\n\n\nThe Library an be \ndownloaded from the ST\nwebsite\n (free\nregistration required). A slightly older version is part of the \nSTM8S_Teach\npresentation\n,\n\n\nDon't miss the Examples folder within the downloaded\nzip file. This and \nLujji's\nblog\n is the most\nuseful reference on using this library and programming the STM8 in general.\n\n\nFor use with SDCC the library needs to be patched:\n\n\ngit clone https://github.com/g-gabber/STM8S_StdPeriph_Driver.git\ngit clone https://github.com/gicking/SPL_2.2.0_SDCC_patch.git\ncp ../STM8S_SPL_2.2.0/Libraries/STM8S_StdPeriph_Driver/inc/stm8s.h .\npatch -p1 < ../SPL_2.2.0_SDCC_patch/STM8_SPL_v2.2.0_SDCC.patch\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_conf.h .\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_it.h .\n\n\n\n\nSDCC uses .rel as the file extension for its object files.\n\n\nAdditional patch required for stm8s_itc.c:\n\n\n--- stm8s_itc.c~    2014-10-21 17:32:20.000000000 +0200\n+++ stm8s_itc.c 2016-12-11 21:56:41.786048494 +0100\n@@ -55,9 +55,12 @@\n   return; /* Ignore compiler warning, the returned value is in A register */\n #elif defined _RAISONANCE_ /* _RAISONANCE_ */\n   return _getCC_();\n-#else /* _IAR_ */\n+#elif defined _IAR_ /* _IAR_ */\n   asm(\"push cc\");\n   asm(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n+#else /* _SDCC_ */\n+  __asm__(\"push cc\");\n+  __asm__(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n #endif /* _COSMIC_*/\n }\n\n\n\n\nNow the library can be compiled for the STM8S103 using this Makefile:\n\n\nCC=sdcc\nAR=sdar\nCFLAGS=-c -mstm8 -DSTM8S103 -I ../inc --opt-code-size -I.\nLDFLAGS=-rc\nSOURCES= \\\n    stm8s_adc1.c    stm8s_awu.c stm8s_beep.c    stm8s_clk.c \\\n    stm8s_exti.c    stm8s_flash.c   stm8s_gpio.c    stm8s_i2c.c \\\n    stm8s_itc.c stm8s_iwdg.c    stm8s_rst.c stm8s_spi.c \\\n    stm8s_tim1.c    stm8s_tim2.c    stm8s_tim4.c    stm8s_uart1.c \\\n    stm8s_wwdg.c\n\nOBJECTS=$(SOURCES:.c=.o)\nOBJECTS_LINK=$(SOURCES:.c=.rel)\nEXECUTABLE=stm8s.lib\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n$(AR) $(LDFLAGS) $(EXECUTABLE) $(OBJECTS_LINK)\n\n.c.o:\n    $(CC) $(CFLAGS) $< -o $@\n\nclean:\n    rm -f *.lib *.rst *.rel *.lst *.ihx *.sym *.asm *.lk *.map\n    rm -f $(EXECUTABLE)\n\n\n\n\nThis library can now be used for linking with blink_spl or uart_spl. The\nfiles stm8s_conf.h and stm8s_it.h are still needed for compilation.\n\n\nThe linker does not remove individual unused functions from an object file,\nonly complete object files can be skipped.\n\n\n=> for building a library it is better to separate all functions into\nindividual source files \n\n\nThe SPL folder in this archive contains a script \ndoit\n to separate the\nfunctions before compilation.\nFIXME: description needed\n\n\nA suggestion how to move at least the IRQ vectors away from the libray into\nthe own source files:\nhttp://richs-words.blogspot.de/2010/09/stm8s-interrupt-handling.html\n\n\nInterrupts\n\n\nInterrupt names are defined in stm8s_itc.h\n\n\nDeclaration of an interrupt function for SDCC:\n\n\n/* UART1 TX */\nvoid UART1_TX_IRQHandler(void) __interrupt(ITC_IRQ_UART1_TX)\n{\n}\n\n\n\n\nSet the matching IRQ enable flag and globally allow interrupts:\n\n\nUART1_ITConfig(UART1_IT_TXE, ENABLE);\nenableInterrupts();\n\n\n\n\nNot sure about the meaning of the ITC priorities. It works even without\nthem:\n\n\nITC_DeInit();\nITC_SetSoftwarePriority(ITC_IRQ_UART1_TX, ITC_PRIORITYLEVEL_2);",
            "title": "Using the SPL with SDCC and sduino"
        },
        {
            "location": "/developer/spl/#st-standard-peripherie-library",
            "text": "The Library an be  downloaded from the ST\nwebsite  (free\nregistration required). A slightly older version is part of the  STM8S_Teach\npresentation ,  Don't miss the Examples folder within the downloaded\nzip file. This and  Lujji's\nblog  is the most\nuseful reference on using this library and programming the STM8 in general.  For use with SDCC the library needs to be patched:  git clone https://github.com/g-gabber/STM8S_StdPeriph_Driver.git\ngit clone https://github.com/gicking/SPL_2.2.0_SDCC_patch.git\ncp ../STM8S_SPL_2.2.0/Libraries/STM8S_StdPeriph_Driver/inc/stm8s.h .\npatch -p1 < ../SPL_2.2.0_SDCC_patch/STM8_SPL_v2.2.0_SDCC.patch\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_conf.h .\ncp -av  ../STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/stm8s_it.h .  SDCC uses .rel as the file extension for its object files.  Additional patch required for stm8s_itc.c:  --- stm8s_itc.c~    2014-10-21 17:32:20.000000000 +0200\n+++ stm8s_itc.c 2016-12-11 21:56:41.786048494 +0100\n@@ -55,9 +55,12 @@\n   return; /* Ignore compiler warning, the returned value is in A register */\n #elif defined _RAISONANCE_ /* _RAISONANCE_ */\n   return _getCC_();\n-#else /* _IAR_ */\n+#elif defined _IAR_ /* _IAR_ */\n   asm(\"push cc\");\n   asm(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n+#else /* _SDCC_ */\n+  __asm__(\"push cc\");\n+  __asm__(\"pop a\"); /* Ignore compiler warning, the returned value is in A register */\n #endif /* _COSMIC_*/\n }  Now the library can be compiled for the STM8S103 using this Makefile:  CC=sdcc\nAR=sdar\nCFLAGS=-c -mstm8 -DSTM8S103 -I ../inc --opt-code-size -I.\nLDFLAGS=-rc\nSOURCES= \\\n    stm8s_adc1.c    stm8s_awu.c stm8s_beep.c    stm8s_clk.c \\\n    stm8s_exti.c    stm8s_flash.c   stm8s_gpio.c    stm8s_i2c.c \\\n    stm8s_itc.c stm8s_iwdg.c    stm8s_rst.c stm8s_spi.c \\\n    stm8s_tim1.c    stm8s_tim2.c    stm8s_tim4.c    stm8s_uart1.c \\\n    stm8s_wwdg.c\n\nOBJECTS=$(SOURCES:.c=.o)\nOBJECTS_LINK=$(SOURCES:.c=.rel)\nEXECUTABLE=stm8s.lib\n\nall: $(SOURCES) $(EXECUTABLE)\n\n$(EXECUTABLE): $(OBJECTS)\n$(AR) $(LDFLAGS) $(EXECUTABLE) $(OBJECTS_LINK)\n\n.c.o:\n    $(CC) $(CFLAGS) $< -o $@\n\nclean:\n    rm -f *.lib *.rst *.rel *.lst *.ihx *.sym *.asm *.lk *.map\n    rm -f $(EXECUTABLE)  This library can now be used for linking with blink_spl or uart_spl. The\nfiles stm8s_conf.h and stm8s_it.h are still needed for compilation.  The linker does not remove individual unused functions from an object file,\nonly complete object files can be skipped.  => for building a library it is better to separate all functions into\nindividual source files   The SPL folder in this archive contains a script  doit  to separate the\nfunctions before compilation.\nFIXME: description needed  A suggestion how to move at least the IRQ vectors away from the libray into\nthe own source files:\nhttp://richs-words.blogspot.de/2010/09/stm8s-interrupt-handling.html  Interrupts  Interrupt names are defined in stm8s_itc.h  Declaration of an interrupt function for SDCC:  /* UART1 TX */\nvoid UART1_TX_IRQHandler(void) __interrupt(ITC_IRQ_UART1_TX)\n{\n}  Set the matching IRQ enable flag and globally allow interrupts:  UART1_ITConfig(UART1_IT_TXE, ENABLE);\nenableInterrupts();  Not sure about the meaning of the ITC priorities. It works even without\nthem:  ITC_DeInit();\nITC_SetSoftwarePriority(ITC_IRQ_UART1_TX, ITC_PRIORITYLEVEL_2);",
            "title": "ST Standard Peripherie Library"
        },
        {
            "location": "/developer/bare-metal-programming/",
            "text": "Bare metal programming\n\n\nIt all started by compiling some plain example programs without using any\nlibraries. This avoids the code overhead of the Arduino libraries.\n\n\nLujji posted a \nseries of\narticles\n on bare\nmetal programming of the STM8S CPUs. This is by far the best introduction I\nfound so far. It would have helped me a lot if it would have been around at\nthe time when I started this project.\n\n\nModifications for the sdcc example programs\n\n\nI started my journey into the STM8 world with the\n\nstm8-examples-sdcc\n by\nValentin Dudouyt (vdudouyt), the author of\n\nstm8flash\n.\n\n\nThese examples are still part of the repository in\nexamples/sdcc-examples-stm8. To compile for my STM8S103F3 board they\nrequired some modifications:\n\n\nblinky.c\n: LED pin assignment\n\n\nuart.c\n:  pin assignment (TX is at PD5, RX is at PD6).\n\nThe UART is sending at 1200 Baud => CPU clock only 2MHz instead of 16MHz.\nThe clock divider needs to be configured or a different baud rate prescale value\nhas to be used. Pitfall: The register address for the clock divider is\ndifferent for the STM8S and the STM8L.",
            "title": "Bare metal programming on the STM8"
        },
        {
            "location": "/developer/bare-metal-programming/#bare-metal-programming",
            "text": "It all started by compiling some plain example programs without using any\nlibraries. This avoids the code overhead of the Arduino libraries.  Lujji posted a  series of\narticles  on bare\nmetal programming of the STM8S CPUs. This is by far the best introduction I\nfound so far. It would have helped me a lot if it would have been around at\nthe time when I started this project.",
            "title": "Bare metal programming"
        },
        {
            "location": "/developer/bare-metal-programming/#modifications-for-the-sdcc-example-programs",
            "text": "I started my journey into the STM8 world with the stm8-examples-sdcc  by\nValentin Dudouyt (vdudouyt), the author of stm8flash .  These examples are still part of the repository in\nexamples/sdcc-examples-stm8. To compile for my STM8S103F3 board they\nrequired some modifications:  blinky.c : LED pin assignment  uart.c :  pin assignment (TX is at PD5, RX is at PD6). \nThe UART is sending at 1200 Baud => CPU clock only 2MHz instead of 16MHz.\nThe clock divider needs to be configured or a different baud rate prescale value\nhas to be used. Pitfall: The register address for the clock divider is\ndifferent for the STM8S and the STM8L.",
            "title": "Modifications for the sdcc example programs"
        },
        {
            "location": "/developer/performance/",
            "text": "Performance\n\n\nThe STM8 backend for SDCC has improved a lot since the release of version\n3.6.0 in June 2016. But due to the very small number of registers the code\nsize will almost always be bigger than for the AVR. Depending on the exact\napplication the difference is anywhere between negligible and factor two.\n\n\nComparing code size with the original AVR Arduino\n\n\nBenchmarking the original Arduino examples from Arduino 1.0.5. The simple\nBlinky compiles to 57 bytes of code, the total binary including the sduino\nlibraries is 1868 Bytes (0x74c).\n\n\nSo far, wiring_analog depends on wiring_digital, even when analogWrite is not\nused. This could be solved by compiling the sduino functions separately into\na library.\n\n\n\n\n\n\n\n\nName\n\n\nCode\n\n\nTotal\n\n\nLinked files other than main and wiring\n\n\n\n\n\n\n\n\n\n\n01. Basics/\n\n\n\n\n\n\n\n\n\n\n\n\nBareMinimum\n\n\n2\n\n\n1238\n\n\n-\n\n\n\n\n\n\nBlink\n\n\n57\n\n\n1870\n\n\nwiring_digital\n\n\n\n\n\n\nAnalogReadSerial\n\n\n205\n\n\n3452\n\n\ndigital, analog, serial, print\n\n\n\n\n\n\nDigitalReadSerial\n\n\n57\n\n\n3160\n\n\ndigital, serial, print\n\n\n\n\n\n\nFade\n\n\n226\n\n\n2189\n\n\ndigital, analog\n\n\n\n\n\n\nReadAnalogVoltage\n\n\n\n\n\n\nfloat not yet implemented\n\n\n\n\n\n\n02. Digital/\n\n\n\n\n\n\n\n\n\n\n\n\nDebounce\n\n\n192\n\n\n2016\n\n\ndigital\n\n\n\n\n\n\n\n\nFloat arithmetics\n\n\nFloating point arithmetics is supported by the SDCC standard library, but it\ncomes at a pretty high cost in terms of code space and CPU load. This is how\nmuch the generated code grows by using a single float operation compared to \nusing a long int:\n\n\n\n\n\n\n\n\nFloating point operation\n\n\napprox. code size\n\n\n\n\n\n\n\n\n\n\naddition\n\n\n736 Bytes\n\n\n\n\n\n\nsubtraction\n\n\n754 Bytes\n\n\n\n\n\n\ndivision\n\n\n673 Bytes\n\n\n\n\n\n\nmultiplication\n\n\n907 Bytes\n\n\n\n\n\n\nsinf() or cosf()\n\n\n3346 Bytes\n\n\n\n\n\n\nlog10f()\n\n\n3437 Bytes\n\n\n\n\n\n\n\n\nThe Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple\nsimple program with only very little floating point arithmetics. But it\nalready uses 7336 bytes of flash. A similar sketch using integer arithmetics\nresults in much more compact code occuping only 3791 bytes.\n\n\nFloat does work, but is better to be avoided and replaced by fixed point\narithmetics whenever possible.",
            "title": "Performance comparison and benchmarking"
        },
        {
            "location": "/developer/performance/#performance",
            "text": "The STM8 backend for SDCC has improved a lot since the release of version\n3.6.0 in June 2016. But due to the very small number of registers the code\nsize will almost always be bigger than for the AVR. Depending on the exact\napplication the difference is anywhere between negligible and factor two.",
            "title": "Performance"
        },
        {
            "location": "/developer/performance/#comparing-code-size-with-the-original-avr-arduino",
            "text": "Benchmarking the original Arduino examples from Arduino 1.0.5. The simple\nBlinky compiles to 57 bytes of code, the total binary including the sduino\nlibraries is 1868 Bytes (0x74c).  So far, wiring_analog depends on wiring_digital, even when analogWrite is not\nused. This could be solved by compiling the sduino functions separately into\na library.     Name  Code  Total  Linked files other than main and wiring      01. Basics/       BareMinimum  2  1238  -    Blink  57  1870  wiring_digital    AnalogReadSerial  205  3452  digital, analog, serial, print    DigitalReadSerial  57  3160  digital, serial, print    Fade  226  2189  digital, analog    ReadAnalogVoltage    float not yet implemented    02. Digital/       Debounce  192  2016  digital",
            "title": "Comparing code size with the original AVR Arduino"
        },
        {
            "location": "/developer/performance/#float-arithmetics",
            "text": "Floating point arithmetics is supported by the SDCC standard library, but it\ncomes at a pretty high cost in terms of code space and CPU load. This is how\nmuch the generated code grows by using a single float operation compared to \nusing a long int:     Floating point operation  approx. code size      addition  736 Bytes    subtraction  754 Bytes    division  673 Bytes    multiplication  907 Bytes    sinf() or cosf()  3346 Bytes    log10f()  3437 Bytes     The Arduino standard example '01. Basics/ReadAnalogVoltage' is a very simple\nsimple program with only very little floating point arithmetics. But it\nalready uses 7336 bytes of flash. A similar sketch using integer arithmetics\nresults in much more compact code occuping only 3791 bytes.  Float does work, but is better to be avoided and replaced by fixed point\narithmetics whenever possible.",
            "title": "Float arithmetics"
        },
        {
            "location": "/developer/links/",
            "text": "Links\n\n\nFurther reading and application notes\n\n\nA series of\narticles\n on bare\nmetal programming of the STM8S CPUs. By far the best introduction I\nfound so far. It would have helped me a lot if it would have around at the\ntime when I started this project.\n\n\nQuick introduction to the Arduino.mk\nmakefile\n\non hackaday.com\n\n\nPM0051\n:\nSTM8AF Flash programming manual\n\n\nUM0470\n:\nSTM8 SWIM protocol and debug manual\n\n\nAN2658\n:\nUsing the analog-to-digital converter of the STM8S microcontroller  \n\n\nMany \nexamples and presentations about the\nSTM8S\n\n\nIt contains the \nSPL examples from\nST\n,\none of the most useful resources on the STM8.\n\n\nHardware and pinouts of several ST-Link compatible flash\ntools\n\n\nUsing the\nADC\n\nby Mark Stevens\n\n\nExample for RS-232 handling with\nSPL\n\n\nAN3139\n:\nMigration guideline within the STM8L familiy  \n\n\nSimilar or related projects\n\n\nNone of these projects are related to or part of Sduino. They are written\nindependently, but with a similar goal in mind: To simplify STM8 programming\nfor the beginner.\n\n\nSTM8Sduino\n: A minimalistic\napproach to adopt parts of the Arduino-API to the STM8. Based on IAR and\nCOSMIC compiler (Windows only). Port to SDCC shouldn't be too hard but is\nnot done yet. Low overhead, but basic functions only. No support for porting\nArduino libraries.\n\n\nOther interesting STM8-related projects\n\n\ngdb support for the STM8\n\nSTM8 toolchain with GDB debugger and SDCC. Use the hardware debugging\nfeature of the STM8 with ST-Link and gdb.\n\n\nSTVD-SDCC integration suite",
            "title": "Links and further reading"
        },
        {
            "location": "/developer/links/#links",
            "text": "",
            "title": "Links"
        },
        {
            "location": "/developer/links/#further-reading-and-application-notes",
            "text": "A series of\narticles  on bare\nmetal programming of the STM8S CPUs. By far the best introduction I\nfound so far. It would have helped me a lot if it would have around at the\ntime when I started this project.  Quick introduction to the Arduino.mk\nmakefile \non hackaday.com  PM0051 :\nSTM8AF Flash programming manual  UM0470 :\nSTM8 SWIM protocol and debug manual  AN2658 :\nUsing the analog-to-digital converter of the STM8S microcontroller    Many  examples and presentations about the\nSTM8S  It contains the  SPL examples from\nST ,\none of the most useful resources on the STM8.  Hardware and pinouts of several ST-Link compatible flash\ntools  Using the\nADC \nby Mark Stevens  Example for RS-232 handling with\nSPL  AN3139 :\nMigration guideline within the STM8L familiy",
            "title": "Further reading and application notes"
        },
        {
            "location": "/developer/links/#similar-or-related-projects",
            "text": "None of these projects are related to or part of Sduino. They are written\nindependently, but with a similar goal in mind: To simplify STM8 programming\nfor the beginner.  STM8Sduino : A minimalistic\napproach to adopt parts of the Arduino-API to the STM8. Based on IAR and\nCOSMIC compiler (Windows only). Port to SDCC shouldn't be too hard but is\nnot done yet. Low overhead, but basic functions only. No support for porting\nArduino libraries.",
            "title": "Similar or related projects"
        },
        {
            "location": "/developer/links/#other-interesting-stm8-related-projects",
            "text": "gdb support for the STM8 \nSTM8 toolchain with GDB debugger and SDCC. Use the hardware debugging\nfeature of the STM8 with ST-Link and gdb.  STVD-SDCC integration suite",
            "title": "Other interesting STM8-related projects"
        },
        {
            "location": "/contact/",
            "text": "Contact\n\n\nBug reports and other issues tightly related to the repository\n\n\ngithub issue tracker\n.\n\n\nMore general topics and suggestions\n\n\nThe \nSTM8 board\n of the\nstm32duino forum. It will help to catch my attention to prefix your topic\nwith \"[sduino]\".\n\n\nPlease note that after registering on that forum, you are\n\nrequired\n to post an introduction in the new user board first in order to\naquire the right to post or reply in any other board. Roger is strict on\nthat.\n\n\nemail\n\n\nPlease find my address in the commit messages of the repository (as a simple\ncaptcha test) or use the alias address sduino@gmx.de",
            "title": "Contact"
        },
        {
            "location": "/contact/#contact",
            "text": "Bug reports and other issues tightly related to the repository  github issue tracker .  More general topics and suggestions  The  STM8 board  of the\nstm32duino forum. It will help to catch my attention to prefix your topic\nwith \"[sduino]\".  Please note that after registering on that forum, you are required  to post an introduction in the new user board first in order to\naquire the right to post or reply in any other board. Roger is strict on\nthat.  email  Please find my address in the commit messages of the repository (as a simple\ncaptcha test) or use the alias address sduino@gmx.de",
            "title": "Contact"
        },
        {
            "location": "/about/",
            "text": "About Sduino\n\n\nThe idea is to smoothen the path towards your first successful STM8-based\nproject.\n\n\nThe Arduino project was very successful in offering a simplified API hiding\nmost of the complexity of embedded system programming while still allowing\nfor advanced programming technics.\n\n\nThe SPL (standard peripheral library) \noffered by\nST\n is very\npowerful and provides an relativly easy migration path towards the STM32 CPU\nseries in case a project outgrows the capabilities of the 8-bit STM8 series.\nBut using that library is not very intuitive and still requires a fairly\ndetailed knowledge of the CPU internals. \ncompiling the SPL with\nSDCC\n\n\nTools used\n\n\nThis project is based on free tools that are available for Linux, MacOS, and\nWindows.\nIt uses the small devices C compiler (SDCC) for compiling,\n\nstm8flash\n for uploading the binary\nto the CPU, and simple Makefiles for the build process.\n\n\nSupport for the Cosmic compiler under Windows and integration into the ST\nvisual developer IDE might be possible, but is not done (yet?).\n\n\nThe build process is controlled by a makefile based on the amazing\n\nArduino.mk makefile\n by\n\nSudar\n.\n\n\nProject origin\n\n\nFor a customer I needed to port an existing project from an ATmega to a\nbetter suited (read: cheaper) platform. As the project was based on some\nArduino libraries, porting parts of the Arduino environment was the logical\nfirst step. After doing that porting the firmware was finished in a couple\nof days. Porting some of the more commonly used Arduino libraries was a fun\nproject done in my spare time later.\n\n\nAbout me\n\n\nI am a freelance programmer for embedded systems and electronics developer\nbased in Heidelberg, Germany. I work with embedded systems for more than\n25 years now.\n\n\nExperiences\n\n\ncurrent CPU architectures\n: AVR (ATmega, ATxmega), PIC, STM8, STM32, MCS51\n\n\nclassic CPU architectures\n: 6502, 68HC11, 6809, Z80, MCS48\n\n\nelectronics development\n: optical sensors, laser driver, sensor\nelectronics, measurement equipment, industrial control, SMPS, displays\n(LCD, TFT)",
            "title": "About"
        },
        {
            "location": "/about/#about-sduino",
            "text": "The idea is to smoothen the path towards your first successful STM8-based\nproject.  The Arduino project was very successful in offering a simplified API hiding\nmost of the complexity of embedded system programming while still allowing\nfor advanced programming technics.  The SPL (standard peripheral library)  offered by\nST  is very\npowerful and provides an relativly easy migration path towards the STM32 CPU\nseries in case a project outgrows the capabilities of the 8-bit STM8 series.\nBut using that library is not very intuitive and still requires a fairly\ndetailed knowledge of the CPU internals.  compiling the SPL with\nSDCC  Tools used  This project is based on free tools that are available for Linux, MacOS, and\nWindows.\nIt uses the small devices C compiler (SDCC) for compiling, stm8flash  for uploading the binary\nto the CPU, and simple Makefiles for the build process.  Support for the Cosmic compiler under Windows and integration into the ST\nvisual developer IDE might be possible, but is not done (yet?).  The build process is controlled by a makefile based on the amazing Arduino.mk makefile  by Sudar .  Project origin  For a customer I needed to port an existing project from an ATmega to a\nbetter suited (read: cheaper) platform. As the project was based on some\nArduino libraries, porting parts of the Arduino environment was the logical\nfirst step. After doing that porting the firmware was finished in a couple\nof days. Porting some of the more commonly used Arduino libraries was a fun\nproject done in my spare time later.  About me  I am a freelance programmer for embedded systems and electronics developer\nbased in Heidelberg, Germany. I work with embedded systems for more than\n25 years now.  Experiences  current CPU architectures : AVR (ATmega, ATxmega), PIC, STM8, STM32, MCS51  classic CPU architectures : 6502, 68HC11, 6809, Z80, MCS48  electronics development : optical sensors, laser driver, sensor\nelectronics, measurement equipment, industrial control, SMPS, displays\n(LCD, TFT)",
            "title": "About Sduino"
        }
    ]
}